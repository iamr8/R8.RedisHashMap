using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

namespace R8.RedisHashMap
{
    [Generator]
    public class SourceGeneration : IIncrementalGenerator
    {
        // private static readonly List<string> GeneratedTypes = new List<string>();
        private static readonly string Namespace = typeof(SourceGeneration).Namespace!;

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // register a syntax receiver that will create source for any class that implements IRedisCacheModel
            var declares = context.SyntaxProvider
                .CreateSyntaxProvider(Predicate, Transform);

            var provider = context.CompilationProvider.Combine(declares.Collect());

            context.RegisterSourceOutput(provider, Execute);
        }

        private void Execute(SourceProductionContext ctx, (Compilation Left, ImmutableArray<(ClassDeclarationSyntax Class, ISymbol Symbol, List<ITypeSymbol> TypeContexts)?> Right) tuple)
        {
            var allConverters = new List<ConverterTypeSymbol>();
            foreach (var right in tuple.Right)
            {
                if (right is null)
                    continue;

                var (classDeclaration, contextSymbol, typeContexts) = right.Value;
                if (typeContexts.Count == 0)
                    continue;

                var typeFullQualifiedName = contextSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                // GenerateCacheableContext(ctx, typeFullQualifiedName, contextSymbol);
                // GenerateGetCacheableTypeInfo(ctx, typeFullQualifiedName, contextSymbol, typeContexts);
                foreach (var objectTypeSymbol in typeContexts)
                {
                    var props = GetPropertySymbols(objectTypeSymbol);
                    if (props.Length == 0)
                        continue;

                    var objectType = TypeSymbol.Create(objectTypeSymbol);

                    if (objectType.TryGetConverter(out var oc) && !allConverters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, oc!.ConverterType)))
                        allConverters.Add(oc);

                    if (props?.Any() == true)
                    {
                        foreach (var prop in props)
                        {
                            if (prop.TryGetConverter(out var pc) && !allConverters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, pc!.ConverterType)))
                                allConverters.Add(pc);
                        }
                    }

                    GenerateExtensionSource(ctx, typeFullQualifiedName, contextSymbol, objectType, props.ToImmutableArray());
                }
            }

            if (allConverters.Count > 0)
            {
                foreach (var converter in allConverters)
                {
                    GenerateConverterSource(ctx, converter);
                }
            }
            
            // var assembly = this.GetType().Assembly.GetName();
            // [CodeDom.Compiler.GeneratedCodeAttribute(""{assembly.Name}"", ""{assembly.Version}"")] 
        }

        private void GenerateConverterSource(SourceProductionContext ctx, ConverterTypeSymbol converterSymbol)
        {
            var sourceText = SourceText.From($@"// <auto-generated/>
#nullable enable

namespace {converterSymbol.ConverterType.ContainingNamespace}
{{
    public partial class {converterSymbol.ConverterType.Name}
    {{
        internal static readonly {converterSymbol.ConverterType.Name} Default = new {converterSymbol.ConverterType.Name}();
    }}
}}", Encoding.UTF8);

            var fileName = $"{converterSymbol.ConverterType.ContainingNamespace}.{converterSymbol.ConverterType.Name}.g.cs";

            ctx.AddSource(fileName, sourceText);
            return;
            // ctx.ReportDiagnostic(Diagnostic.Create(
            //     new DiagnosticDescriptor(
            //         "R8.RedisHashMap",
            //         "Generated",
            //         $"Generated source for {displayName}.",
            //         "SourceGeneration",
            //         DiagnosticSeverity.Info,
            //         true),
            //     Location.None));
        }

        private static void GenerateExtensionSource(SourceProductionContext ctx, string context, ISymbol contextSymbol, TypeSymbol objectType, ImmutableArray<TypeSymbol> propertyTypes)
        {
            var displayName = objectType.GetDisplayName();
            var sourceText = SourceText.From($@"// Context: {context}
// Original source: {objectType.Type}
// <auto-generated/>
#nullable enable

using System;
using System.Buffers;
using System.Text;
using System.Text.Json;
using System.Runtime.CompilerServices;

using StackExchange.Redis;

namespace {contextSymbol.ContainingNamespace}
{{
    public static class {displayName}Extensions
    {{
        {GetHashEntries(contextSymbol, objectType, propertyTypes)}
    }}
}}", Encoding.UTF8);

            var fileName = $"{contextSymbol.ContainingNamespace}.{displayName}.g.cs";

            ctx.AddSource(fileName, sourceText);
            // ctx.ReportDiagnostic(Diagnostic.Create(
            //     new DiagnosticDescriptor(
            //         "R8.RedisHashMap",
            //         "Generated",
            //         $"Generated source for {displayName}.",
            //         "SourceGeneration",
            //         DiagnosticSeverity.Info,
            //         true),
            //     Location.None));
        }

        private static string GetHashEntries(ISymbol contextSymbol, TypeSymbol objectType, ImmutableArray<TypeSymbol> propertyTypes)
        {
            var langCode = new StringBuilder();
            if (objectType is { IsDictionary: true, Type: INamedTypeSymbol nts })
            {
                var keyArgType = TypeSymbol.Create(nts.TypeArguments[0]);
                var valueArgType = TypeSymbol.Create(nts.TypeArguments[1]);

                // var keySupported = keyArgType.TryGetRedisValue(contextSymbol, null, "kvp.Key", "", out var keyLangCode);
                // var valueSupported = valueArgType.TryGetRedisValue(contextSymbol, null, "kvp.Value", "", out var valueLangCode);
//                 langCode.Append(@$"public static HashEntry[] GetHashEntries(this {objectType} obj)
//         {{
//             var entries = new HashEntry[obj.Count];
//
//             var index = -1;
//             foreach (var kvp in obj)
//             {{
//                 {(keySupported ? $"var key = {keyLangCode};" : $"throw new NotSupportedException($\"Cannot convert `{keyArgType.Type}` to `RedisValue`.\");")}
//                 {(valueSupported ? $"var value = {valueLangCode};" : $"throw new NotSupportedException($\"Cannot convert `{valueArgType.Type}` to `RedisValue`.\");")}
//                 {(keySupported && valueSupported ? "entries[++index] = new HashEntry(key, value);" : "")}
//             }}
//
//             return entries;
//         }}");
            }
            else
            {
                langCode.Append(@$"{GetFields(propertyTypes)}

        private static readonly ArrayPool<HashEntry> arrayPool = ArrayPool<HashEntry>.Create({propertyTypes.Length}, 1_000);
        private static readonly Encoding encoding = Encoding.UTF8;
        private static readonly HashEntry[] emptyArray = Array.Empty<HashEntry>();
        
        [ThreadStatic]
        private static ArrayBufferWriter<byte> _reusableByteBufferWriter;

        [ThreadStatic]
        private static Utf8JsonWriter _reusableJsonWriter;

        private static readonly JsonWriterOptions ReusableJsonWriterOptions = new JsonWriterOptions
        {{
            Indented = false,
            SkipValidation = false
        }};

        public static HashEntry[] GetHashEntries(this {objectType} obj, JsonSerializerOptions? serializerOptions = null)
        {{
            HashEntry[] entries = arrayPool.Rent({propertyTypes.Length});
            Span<HashEntry> entriesSpan = entries.AsSpan();
            int index = -1;

            // TODO: Initialize buffer only if needed
            ArrayBufferWriter<byte> bufferWriter = GetReusableBufferWriter();

            try
            {{
                {string.Join(@$"
                
                ", propertyTypes.Select((propertyType, i) =>
                {
                    // var parser = GetParser(objectTypeSymbol, property);
                    var propertySymbol = propertyType.Symbol;
                    var wrapper = propertyType.GetProperty(contextSymbol, propertySymbol!);
                    if (wrapper != null)
                    {
                        return wrapper;
                    }
                    else
                    {
                        // stringBuilder.Append($"obj.{propertySymbol!.Name}");
                    }

                    return $"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");";
                }))}

                if (index == -1)
                    return emptyArray;

                int finalCount = index + 1;
                HashEntry[] resultArray = new HashEntry[finalCount];
                entriesSpan.Slice(0, finalCount).CopyTo(resultArray);
                return resultArray;
            }}
            finally
            {{
                bufferWriter.Clear();
                arrayPool.Return(entries);
            }}
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ArrayBufferWriter<byte> GetReusableBufferWriter()
        {{
            var writer = _reusableByteBufferWriter;
            if (writer == null)
            {{
                writer = new ArrayBufferWriter<byte>();
                _reusableByteBufferWriter = writer;
            }}
            return writer;
        }}
 
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static Utf8JsonWriter GetReusableJsonWriter(ArrayBufferWriter<byte> writer)
        {{
            var jsonWriter = _reusableJsonWriter;
            if (jsonWriter == null)
            {{
                jsonWriter = new Utf8JsonWriter(writer, ReusableJsonWriterOptions);
                _reusableJsonWriter = jsonWriter;
            }}
            else
            {{
                jsonWriter.Reset(writer);
            }}
            return jsonWriter;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static RedisValue SerializeString(ArrayBufferWriter<byte> bufferWriter, ReadOnlySpan<char> value)
        {{
            bufferWriter.Clear();
            int byteCount = Encoding.UTF8.GetByteCount(value);
            Span<byte> bytes = bufferWriter.GetSpan(byteCount);
            int bytesWritten = Encoding.UTF8.GetBytes(value, bytes);
            bufferWriter.Advance(bytesWritten);
            return (RedisValue)bufferWriter.WrittenMemory;
        }}
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static RedisValue SerializeJson<T>(ArrayBufferWriter<byte> bufferWriter, T value, JsonSerializerOptions? serializerOptions)
        {{
            bufferWriter.Clear();
            Utf8JsonWriter jsonWriter = GetReusableJsonWriter(bufferWriter);
            JsonSerializer.Serialize(_reusableJsonWriter, value, serializerOptions);
            _reusableJsonWriter.Flush();
            return (RedisValue)bufferWriter.WrittenMemory;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static RedisValue SerializeJsonElement(ArrayBufferWriter<byte> bufferWriter, JsonElement value)
        {{
            return (RedisValue)value.GetBytesFromBase64();
        }}");
            }

            return langCode.ToString();
        }

        private static string GetFields(ImmutableArray<TypeSymbol> propertyTypes)
        {
            return @$"{string.Join(@"
        ", propertyTypes.Select((propertyType, i) =>
            {
                var redisFieldName = RedisFieldName(propertyType);

                return $@"private static readonly RedisValue field_{propertyType.Symbol!.Name} = new RedisValue(""{redisFieldName}"");";
            }))}";
        }

        private static string RedisFieldName(TypeSymbol symbol)
        {
            var propertyName = symbol.Symbol!.Name;

            var attributes = symbol.Symbol.GetAttributes();
            var jsonPropertyNameAttr = attributes.FirstOrDefault(c => c.AttributeClass.Name.Equals(nameof(JsonPropertyNameAttribute), StringComparison.Ordinal));
            if (jsonPropertyNameAttr != null)
                propertyName = (string)jsonPropertyNameAttr.ConstructorArguments[0].Value!;

            return propertyName;
        }

        // private static string GetParser(ITypeSymbol objectTypeSymbol, TypeSymbol prop)
        // {
        //     if (prop.IsValueType)
        //     {
        //         if (prop.IsUnmanagedType)
        //         {
        //             if (prop.IsEnum)
        //             {
        //                 if (prop.HasConverter)
        //                 {
        //                     if (prop.IsPropertyOrField)
        //                     {
        //                         return $"static (obj, value) => (({objectTypeSymbol})obj).{prop.Symbol!.Name} = {prop.ConverterTypeSymbol}.Default.ConvertFromRedisValue(value)";
        //                     }
        //                     else
        //                     {
        //                         return $"static (_, value) => _ = {prop.ConverterTypeSymbol}.Default.ConvertFromRedisValue(value)";
        //                     }
        //                 }
        //                 else
        //                 {
        //                     if (prop.IsNullable)
        //                         return $"static (obj, value) => !value.IsNullOrEmpty ? ({prop.Type})value.Value : ({prop.Type}?)null";
        //
        //                     return $"static (obj, value) => !value.IsNullOrEmpty ? ({prop.Type})value.Value : default({prop.Type})";
        //                 }
        //             }
        //             else if (prop.HasConverter)
        //             {
        //                 return $"static (obj, value) => {prop.ConverterTypeSymbol}.Default.ConvertFromRedisValue(value)";
        //             }
        //             else
        //             {
        //                 return $"static (obj, value) => ({prop.Type})value";
        //             }
        //         }
        //         else
        //         {
        //             return $"static (obj, value) => throw new NotSupportedException($\"000 Cannot convert {{value}} to {{typeof({prop})}}. Targeted property: {{nameof({prop.Type.Name})}}\");";
        //         }
        //     }
        //     else if (prop.IsReferenceType)
        //     {
        //         if (prop.HasConverter)
        //         {
        //             return $"static (obj, value) => {prop.ConverterTypeSymbol}.Default.ConvertFromRedisValue(value)";
        //         }
        //
        //         if (prop.IsString)
        //         {
        //             return $"static (obj, value) => ({prop})value!";
        //         }
        //         else if (prop.IsJsonDocument)
        //         {
        //             return $"static (obj, value) => Text.Json.JsonDocument.Parse((ReadOnlyMemory<byte>)value)";
        //         }
        //         else
        //         {
        //             // if (objectTypeSymbol.HasJsonSerializable)
        //             // {
        //             //     var underlyingType = TryGetNullableUnderlyingType(propTypeSymbol, out var underlying) ? underlying : propTypeSymbol;
        //             //     return $"value => Text.Json.JsonSerializer.Deserialize<{underlyingType}>(((ReadOnlyMemory<byte>)value).Span, this.Options)!";
        //             // }
        //             // else
        //             // {
        //             //     var underlyingType = TryGetNullableUnderlyingType(propTypeSymbol, out var underlying) ? underlying : propTypeSymbol;
        //             //     return $"value => Text.Json.JsonSerializer.Deserialize<{underlyingType}>(((ReadOnlyMemory<byte>)value).Span, this.Options)!";
        //             // }
        //
        //             return $"(obj, value) => Text.Json.JsonSerializer.Deserialize<{prop.Type}>(((ReadOnlyMemory<byte>)value).Span, this.Options)!";
        //         }
        //     }
        //
        //     return $"static (obj, value) => throw new NotSupportedException($\"CCC Cannot convert {{value}} to {{typeof({prop})}}. Targeted property: {{nameof({prop.Type.Name})}}\");";
        // }

        private static (ClassDeclarationSyntax Class, ISymbol ContextSymbol, List<ITypeSymbol> TypeContexts)? Transform(GeneratorSyntaxContext syntaxContext, CancellationToken cancellationToken)
        {
            if (!(syntaxContext.Node is ClassDeclarationSyntax classDeclaration))
                return null;

            var classSymbol = ModelExtensions.GetDeclaredSymbol(syntaxContext.SemanticModel, classDeclaration, cancellationToken: cancellationToken);
            if (classSymbol == null)
                return null;

            var typeContexts = new List<ITypeSymbol>();
            foreach (var attributeListSyntax in classDeclaration.AttributeLists)
            {
                foreach (var attributeSyntax in attributeListSyntax.Attributes)
                {
                    if (!TryGetAttribute(attributeSyntax, nameof(JsonSerializableAttribute).Replace("Attribute", ""), syntaxContext, out var argType))
                        continue;

                    if (typeContexts.Any(typeContext => SymbolEqualityComparer.Default.Equals(typeContext, argType)))
                        continue;

                    typeContexts.Add(argType!);
                    // typeContexts.Add(new ObjectTypeSymbol
                    // {
                    //     Type = argType!,
                    //     HasJsonSerializable = classDeclaration.AttributeLists.Any(c => c.Attributes.Any(attrSyntax => TryGetAttribute(attrSyntax, nameof(JsonSerializableAttribute).Replace("Attribute", ""), syntaxContext, out var argT) && SymbolEqualityComparer.Default.Equals(argType, argT)))
                    // });
                }
            }

            return (classDeclaration, classSymbol, typeContexts);
        }

        private static bool TryGetAttribute(AttributeSyntax attributeSyntax, string attributeName, GeneratorSyntaxContext syntaxContext, out ITypeSymbol? argType)
        {
            argType = null;
            if (!(attributeSyntax.Name is IdentifierNameSyntax nameSyntax))
                return false;

            if (!nameSyntax.Identifier.Text.Equals(attributeName, StringComparison.Ordinal))
                return false;

            if (attributeSyntax.ArgumentList is null)
                return false;

            foreach (var attributeArgumentSyntax in attributeSyntax.ArgumentList.Arguments)
            {
                var expressionSyntax = attributeArgumentSyntax.Expression;
                var operation = syntaxContext.SemanticModel.GetOperation(expressionSyntax) as ITypeOfOperation;
                var typeOperand = operation?.TypeOperand;
                if (typeOperand == null)
                    continue;

                argType = typeOperand;
            }

            if (argType == null)
                return false;

            return true;
        }

        private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            if (!(syntaxNode is ClassDeclarationSyntax classDeclaration))
                return false;

            if (!classDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword) && !classDeclaration.Modifiers.Any(SyntaxKind.InternalKeyword))
                return false;

            if (!classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
                return false;

            var baseList = classDeclaration.BaseList;
            if (baseList == null)
                return false;

            var types = baseList.Types;
            if (types.Count == 0)
                return false;

            foreach (var type in types)
            {
                if (!(type.Type is IdentifierNameSyntax identifier))
                    continue;

                if (!identifier.Identifier.Text.Equals(nameof(JsonSerializerContext), StringComparison.Ordinal))
                    continue;

                return true;
            }

            return false;
        }

        private static TypeSymbol[] GetPropertySymbols(ITypeSymbol objectTypeSymbol)
        {
            if (objectTypeSymbol.Kind != SymbolKind.NamedType)
                return Array.Empty<TypeSymbol>();

            var props = new List<TypeSymbol>();
            var namedTypeSymbol = (INamedTypeSymbol)objectTypeSymbol;
            foreach (var symbol in namedTypeSymbol.GetMembers())
            {
                if (symbol is IPropertySymbol propSymbol)
                {
                    if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
                        continue;

                    if (propSymbol.DeclaredAccessibility == Accessibility.Private)
                    {
                        // if (!includePrivate)
                        continue;
                    }

                    var attributes = propSymbol.GetAttributes();
                    if (attributes.Any(x => x.AttributeClass.Name.Equals(nameof(JsonIgnoreAttribute), StringComparison.Ordinal)))
                        continue;

                    props.Add(TypeSymbol.Create(symbol));
                }
                else if (symbol is IFieldSymbol fieldSymbol)
                {
                    // if (!includeFields)
                    continue;

                    if (fieldSymbol.DeclaredAccessibility == Accessibility.Private)
                    {
                        // if (!includePrivate)
                        continue;
                    }

                    if (fieldSymbol.AssociatedSymbol != null)
                        continue;

                    if (fieldSymbol.IsReadOnly)
                        continue;

                    props.Add(TypeSymbol.Create(symbol));
                }
                else
                {
                    continue;
                }
            }

            // var baseType = namedTypeSymbol.BaseType;
            // while (baseType != null)
            // {
            //     foreach (var propSymbol in baseType.GetMembers().OfType<IPropertySymbol>())
            //     {
            //         if (propSymbol.DeclaredAccessibility != Accessibility.Public)
            //             continue;
            //         if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
            //             continue;
            //
            //         var exists = false;
            //         for (var i = 0; i < lastIndex + 1; i++)
            //         {
            //             exists = props.Span[i].Name.Equals(propSymbol.Name, StringComparison.Ordinal);
            //             if (exists)
            //                 break;
            //         }
            //
            //         if (!exists)
            //             props.Span[++lastIndex] = propSymbol;
            //     }
            //
            //     baseType = baseType.BaseType;
            // }

            // if (lastIndex == -1)
            // return Array.Empty<TypeSymbol>();

            // props = props[..(lastIndex + 1)];
            return props.ToArray();
        }
    }
}