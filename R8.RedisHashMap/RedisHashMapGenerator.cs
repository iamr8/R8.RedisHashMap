using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using StackExchange.Redis;

namespace R8.RedisHashMap
{
    [Generator]
    public class RedisHashMapGenerator : IIncrementalGenerator
    {
        private static readonly List<string> GeneratedTypes = new List<string>();

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // register a syntax receiver that will create source for any class that implements IRedisCacheModel
            var declares = context.SyntaxProvider
                .CreateSyntaxProvider(Predicate, Transform);

            var provider = context.CompilationProvider.Combine(declares.Collect());

            context.RegisterSourceOutput(provider, Execute);
        }

        private void Execute(SourceProductionContext ctx, (Compilation Left, ImmutableArray<ISymbol> Right) symbol)
        {
            var (_, namedTypeSymbols) = symbol;
            foreach (var type in namedTypeSymbols)
            {
                var typeFullQualifiedName = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                if (GeneratedTypes.Contains(typeFullQualifiedName, StringComparer.Ordinal))
                    continue;

                var props = GetPropertySymbols(type);
                if (props.Length == 0)
                    continue;

                var resolvedProps = props
                    .Select(symbol1 => (Symbol: symbol1, Type: symbol1 switch
                    {
                        IPropertySymbol ps => ps.Type,
                        IFieldSymbol fs => fs.Type,
                        _ => null
                    }))
                    .ToArray();

                var sourceText = SourceText.From($@"// Original source: {typeFullQualifiedName}
// <auto-generated/>

namespace {type.ContainingNamespace}
{{
    public partial class {type.Name} : global::R8.RedisHashMap.{nameof(IRedisHashMap)}
    {{
        private static int _propsLength = {resolvedProps.Length};

        private static global::System.Collections.Immutable.ImmutableArray<string> _props = global::System.Collections.Immutable.ImmutableArray.Create(new[] {{ {string.Join(", ", resolvedProps.Select(x => $"nameof({x.Symbol.Name})"))} }});

        public global::StackExchange.Redis.HashEntry[] GetHashEntries()
        {{
            Memory<global::StackExchange.Redis.HashEntry> fields = new global::StackExchange.Redis.HashEntry[_propsLength];
            int lastIndex = -1;
            {string.Join(@"
            ", resolvedProps.Select((x, i) => GetMethod(x.Symbol, x.Type)))}

            fields = fields.Slice(0, lastIndex + 1);
            return fields.ToArray();
        }}

        public global::StackExchange.Redis.RedisValue[] GetHashFields()
        {{
            var fields = new global::StackExchange.Redis.RedisValue[_propsLength];
            for (int i = 0; i < _propsLength; i++)
            {{
                fields[i] = (string)_props[i];
            }}
            return fields;
        }}

        public void Init(global::StackExchange.Redis.RedisValue[] fields, global::StackExchange.Redis.RedisValue[] values)
        {{
            for (int i = 0; i < _propsLength; i++)
            {{
                var field = fields[i];
                var value = values[i];

                switch (field)
                {{
                    {string.Join(@"
                    ", resolvedProps.Select(c => $@"case nameof({c.Symbol.Name}): PropInit{c.Symbol.Name}(value); break;"))}
                }}
            }}
        }}

        {string.Join(@"

        ", resolvedProps.Select(x => $@"private void PropInit{x.Symbol.Name}(global::StackExchange.Redis.RedisValue value)
        {{
            {SetMethod(x.Symbol, x.Type)}
        }}"))}
    }}
}}", Encoding.UTF8);

                var fileName = $"{type.Name}.HashMap.g.cs";
                // GeneratedTypes.Add(typeFullQualifiedName);
                ctx.AddSource(fileName, sourceText);
            }
        }

        private static string GetMethod(ISymbol symbol, ITypeSymbol type)
        {
            switch (type.TypeKind)
            {
                case TypeKind.Array:
                {
                    return GetArray(symbol, type);
                }
                case TypeKind.Class:
                {
                    if (type.SpecialType == SpecialType.System_String)
                        return GetString(symbol);

                    if (type.AllInterfaces.Any(x => x.Name.Equals(nameof(IEnumerable), StringComparison.Ordinal)))
                        return GetEnumerable(symbol, type);

                    return GetClass(symbol, type);
                }
                case TypeKind.Enum:
                {
                    return GetEnum(symbol, false);
                }
                case TypeKind.Struct:
                {
                    return GetStruct(symbol, type, false);
                }
                case TypeKind.Interface:
                case TypeKind.Unknown:
                case TypeKind.Delegate:
                case TypeKind.Dynamic:
                case TypeKind.Error:
                case TypeKind.Module:
                case TypeKind.Pointer:
                case TypeKind.TypeParameter:
                case TypeKind.Submission:
                case TypeKind.FunctionPointer:
                default:
                {
                    return $"// ignore {symbol.Name}";
                    // return $"throw new global::System.InvalidOperationException($\"Cannot convert {{value}} to {{typeof({type})}}. Targeted property: {{nameof({symbol.Name})}}\");";
                }
            }
        }

        private static string GetStruct(ISymbol symbol, ITypeSymbol type, bool nullable)
        {
            return type.SpecialType switch
            {
                SpecialType.System_Int16 => GetInt16(symbol, nullable),
                SpecialType.System_UInt16 => GetUInt16(symbol, nullable),
                SpecialType.System_Int32 => GetInt32(symbol, nullable),
                SpecialType.System_UInt32 => GetUInt32(symbol, nullable),
                SpecialType.System_Int64 => GetInt64(symbol, nullable),
                SpecialType.System_UInt64 => GetUInt64(symbol, nullable),
                SpecialType.System_Double => GetDouble(symbol, nullable),
                SpecialType.System_Decimal => GetDecimal(symbol, nullable),
                SpecialType.System_Boolean => GetBoolean(symbol, nullable),
                SpecialType.System_Char => GetChar(symbol, nullable),
                SpecialType.System_Single => GetFloat(symbol, nullable),
                SpecialType.System_DateTime => GetDateTime(symbol, nullable),
                SpecialType.None => GetUnknownStruct(symbol, type, nullable)
            };
        }

        private static string GetUnknownStruct(ISymbol symbol, ITypeSymbol type, bool nullable)
        {
            if (type.Name.Equals("ReadOnlyMemory", StringComparison.Ordinal))
            {
                if (type is INamedTypeSymbol namedTypeSymbol)
                {
                    if (namedTypeSymbol.TypeArguments.Length == 1 && namedTypeSymbol.TypeArguments[0].SpecialType == SpecialType.System_Byte)
                    {
                        return GetReadOnlyMemory(symbol, nullable);
                    }
                }
            }

            if (type.Name.Equals("Memory", StringComparison.Ordinal))
            {
                if (type is INamedTypeSymbol namedTypeSymbol)
                {
                    if (namedTypeSymbol.TypeArguments.Length == 1 && namedTypeSymbol.TypeArguments[0].SpecialType == SpecialType.System_Byte)
                    {
                        return GetMemory(symbol, nullable);
                    }
                }
            }
            else if (type.Name.Equals("Nullable", StringComparison.Ordinal))
            {
                if (type is INamedTypeSymbol namedTypeSymbol)
                {
                    if (namedTypeSymbol.TypeArguments.Length == 1)
                    {
                        var genericType = namedTypeSymbol.TypeArguments[0];
                        return GetStruct(symbol, genericType, true);
                    }
                }
            }
            else if (type.Name.Equals(nameof(TimeSpan), StringComparison.Ordinal))
            {
                return GetTimeSpan(symbol, nullable);
            }
            else if (type.TypeKind == TypeKind.Enum)
            {
                return GetEnum(symbol, true);
            }
            else if (type.Name.Equals(nameof(RedisValue), StringComparison.Ordinal))
            {
                return GetRedisValue(symbol, nullable);
            }

            return $"// ignore {symbol.Name}";
        }

        private static string GetRedisValue(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }};"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetReadOnlyMemory(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (ReadOnlyMemory<byte>)this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (ReadOnlyMemory<byte>)this.{symbol.Name});";
        }

        private static string GetMemory(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (Memory<byte>)this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (Memory<byte>)this.{symbol.Name});";
        }

        private static string GetTimeSpan(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value.Ticks); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Ticks);";
        }

        private static string GetDateTime(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value.Ticks); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Ticks);";
        }

        private static string GetFloat(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (float)this.{symbol.Name});";
        }

        private static string GetChar(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (uint)this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (uint)this.{symbol.Name});";
        }

        private static string GetBoolean(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetDecimal(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (double)this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (double)this.{symbol.Name});";
        }

        private static string GetDouble(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetUInt64(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetInt64(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetUInt32(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetInt32(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetUInt16(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (uint)this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (uint)this.{symbol.Name});";
        }

        private static string GetInt16(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetEnum(ISymbol symbol, bool nullable)
        {
            return nullable
                ? $"if (this.{symbol.Name}.HasValue) {{ fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.Value.ToString().ToUpperInvariant()); }}"
                : $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name}.ToString().ToUpperInvariant());";
        }

        private static string GetClass(ISymbol symbol, ITypeSymbol type)
        {
            return $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), global::System.Text.Json.JsonSerializer.SerializeToUtf8Bytes<{type}>(this.{symbol.Name}));";
        }

        private static string GetEnumerable(ISymbol symbol, ITypeSymbol type)
        {
            return $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), global::System.Text.Json.JsonSerializer.SerializeToUtf8Bytes<{type}>(this.{symbol.Name}));";
        }

        private static string GetString(ISymbol symbol)
        {
            return $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), this.{symbol.Name});";
        }

        private static string GetArray(ISymbol symbol, ITypeSymbol type)
        {
            if (type is IArrayTypeSymbol arrayTypeSymbol)
            {
                if (arrayTypeSymbol.ElementType.SpecialType == SpecialType.System_Byte)
                {
                    return $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), (byte[])this.{symbol.Name});";
                }
                else
                {
                    return $"fields.Span[++lastIndex] = new global::StackExchange.Redis.HashEntry(nameof({symbol.Name}), global::System.Text.Json.JsonSerializer.SerializeToUtf8Bytes<{type}>(this.{symbol.Name}));";
                }
            }

            return $"throw new global::System.NotSupportedException($\"Cannot convert {{value}} to {{typeof({type})}}. Targeted property: {{nameof({symbol.Name})}}\");";
        }

        private static string SetInt32(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = (int)value;
                return;
            }}
            
            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string SetUInt32(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = (uint)value;
                return;
            }}
            
            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string SetInt64(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = (long)value;
                return;
            }}
            
            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string SetUInt64(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = (ulong)value;
                return;
            }}
            
            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string CastInt16(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = (short)value;
                return;
            }}

            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string CastByte(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            this.{symbol.Name} = checked((byte)(uint)value);";
        }

        private static string CastChar(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNullOrEmpty)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            this.{symbol.Name} = checked((char)(uint)value);";
        }

        private static string SetBoolean(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            this.{symbol.Name} = (bool)value;";
        }

        private static string CastUInt16(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = checked((ushort)(uint)value);
                return;
            }}
            
            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string SetDouble(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = (double)value;
                return;
            }}
            
            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string SetFloat(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = (float)value;
                return;
            }}
            
            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string SetRedisValue(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNullOrEmpty)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            this.{symbol.Name} = value;";
        }

        private static string SetEnum(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNullOrEmpty)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = ({type})(int)value;
                return;
            }}
            
            this.{symbol.Name} = global::System.Enum.Parse<{type}>(value.ToString());";
        }

        private static string SetDateTime(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNullOrEmpty)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = new global::System.DateTime((long)value);
                return;
            }}
            
            this.{symbol.Name} = global::System.DateTime.Parse(value);";
        }

        private static string SetTimeSpan(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNullOrEmpty)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = global::System.TimeSpan.FromTicks((long)value);
                return;
            }}
            
            this.{symbol.Name} = global::System.TimeSpan.Parse(value);";
        }

        private static string SetDecimal(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return $@"if (value.IsNull)
            {{
                {(parentType is { NullableAnnotation: NullableAnnotation.Annotated } ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            if (value.IsInteger)
            {{
                this.{symbol.Name} = (decimal)value;
                return;
            }}
            
            throw new global::System.InvalidOperationException($""Cannot convert {{value}} to {{typeof({parentType ?? type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
        }

        private static string SetUnknownStruct(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            if (type.Name.Equals("ReadOnlyMemory", StringComparison.Ordinal))
            {
                if (type is INamedTypeSymbol namedTypeSymbol)
                {
                    if (namedTypeSymbol.TypeArguments.Length == 1 && namedTypeSymbol.TypeArguments[0].SpecialType == SpecialType.System_Byte)
                    {
                        return $@"if (value.Length() == 0)
            {{
                {(type.NullableAnnotation == NullableAnnotation.Annotated ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = ReadOnlyMemory<byte>.Empty;")}
                return;
            }}

            this.{symbol.Name} = (global::System.ReadOnlyMemory<byte>)value;";
                    }
                }
            }
            else if (type.Name.Equals("Nullable", StringComparison.Ordinal))
            {
                if (type is INamedTypeSymbol namedTypeSymbol)
                {
                    if (namedTypeSymbol.TypeArguments.Length == 1)
                    {
                        var genericType = namedTypeSymbol.TypeArguments[0];
                        return SetStruct(symbol, genericType, type);
                    }
                }
            }
            else if (type.Name.Equals(nameof(TimeSpan), StringComparison.Ordinal))
            {
                return SetTimeSpan(symbol, type, parentType);
            }
            else if (type.TypeKind == TypeKind.Enum)
            {
                return SetEnum(symbol, type, parentType);
            }
            else if (type.Name.Equals(nameof(RedisValue), StringComparison.Ordinal))
            {
                return SetRedisValue(symbol, type, parentType);
            }

            return $"throw new global::System.NotSupportedException($\"Cannot convert {{value}} to {{typeof({type})}}. Targeted property: {{nameof({symbol.Name})}}\");";
        }

        private static string SetArray(ISymbol symbol, IArrayTypeSymbol type)
        {
            if (type.ElementType.SpecialType == SpecialType.System_Byte)
            {
                return $@"if (value.Length() == 0)
            {{
                {(type.NullableAnnotation == NullableAnnotation.Annotated ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = Array.Empty<byte>();")}
                return;
            }}

            this.{symbol.Name} = (byte[])value;";
            }
            else
            {
                return $@"if (value.IsNullOrEmpty)
            {{
                {(type.NullableAnnotation == NullableAnnotation.Annotated ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = Array.Empty<{type.ElementType}>();")}
                return;
            }}

            this.{symbol.Name} = global::System.Text.Json.JsonSerializer.Deserialize<{type}>(((ReadOnlyMemory<byte>)value).Span);";
            }
        }

        private static string SetMethod(ISymbol symbol, ITypeSymbol type)
        {
            switch (type.TypeKind)
            {
                case TypeKind.Array:
                {
                    if (type is IArrayTypeSymbol arrayTypeSymbol)
                        return SetArray(symbol, arrayTypeSymbol);

                    return $@"throw new global::System.NotSupportedException($""Cannot convert {{value}} to {{typeof({type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
                }
                case TypeKind.Class:
                {
                    if (type.SpecialType == SpecialType.System_String)
                        return SetString(symbol, type);

                    if (type.AllInterfaces.Any(x => x.Name.Equals(nameof(IEnumerable), StringComparison.Ordinal)))
                        return SetEnumerable(symbol, type);

                    return SetClass(symbol, type);
                }
                case TypeKind.Enum:
                {
                    return SetEnum(symbol, type, null);
                }
                case TypeKind.Struct:
                {
                    return SetStruct(symbol, type, null);
                }
                case TypeKind.Unknown:
                case TypeKind.Interface:
                case TypeKind.Delegate:
                case TypeKind.Dynamic:
                case TypeKind.Error:
                case TypeKind.Module:
                case TypeKind.Pointer:
                case TypeKind.TypeParameter:
                case TypeKind.Submission:
                case TypeKind.FunctionPointer:
                default:
                    return $@"throw new global::System.NotSupportedException($""Cannot convert {{value}} to {{typeof({type})}}. Targeted property: {{nameof({symbol.Name})}}"");";
            }
        }

        private static string SetClass(ISymbol symbol, ITypeSymbol type)
        {
            return $@"if (value.IsNullOrEmpty)
            {{
                {(type.NullableAnnotation == NullableAnnotation.Annotated || type.IsReferenceType ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            this.{symbol.Name} = global::System.Text.Json.JsonSerializer.Deserialize<{type}>(((ReadOnlyMemory<byte>)value).Span);";
        }

        private static string SetEnumerable(ISymbol symbol, ITypeSymbol type)
        {
            return $@"if (value.IsNullOrEmpty)
            {{
                {(type.NullableAnnotation == NullableAnnotation.Annotated ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = new {type}();")}
                return;
            }}

            this.{symbol.Name} = global::System.Text.Json.JsonSerializer.Deserialize<{type}>(((ReadOnlyMemory<byte>)value).Span);";
        }

        private static string SetString(ISymbol symbol, ITypeSymbol type)
        {
            // if (symbol is IPropertySymbol { SetMethod: null })
            // return $"throw new global::System.InvalidOperationException($\"Cannot set value to {{nameof({symbol.Name})}}. It's readonly property.\");";
            // if (symbol is IFieldSymbol { IsReadOnly: true })
            // return $"throw new global::System.InvalidOperationException($\"Cannot set value to {{nameof({symbol.Name})}}. It's readonly field.\");";

            return $@"if (value.IsNullOrEmpty)
            {{
                {(type.NullableAnnotation == NullableAnnotation.Annotated || type.IsReferenceType ? $"this.{symbol.Name} = null;" : $"this.{symbol.Name} = default;")}
                return;
            }}

            this.{symbol.Name} = value.ToString();";
        }

        private static string SetStruct(ISymbol symbol, ITypeSymbol type, ITypeSymbol? parentType)
        {
            return type.SpecialType switch
            {
                // SpecialType.System_Byte => CastByte(symbol, type, parentType),
                SpecialType.System_Char => CastChar(symbol, type, parentType),
                SpecialType.System_Int16 => CastInt16(symbol, type, parentType),
                SpecialType.System_UInt16 => CastUInt16(symbol, type, parentType),
                SpecialType.System_Int32 => SetInt32(symbol, type, parentType),
                SpecialType.System_UInt32 => SetUInt32(symbol, type, parentType),
                SpecialType.System_Int64 => SetInt64(symbol, type, parentType),
                SpecialType.System_UInt64 => SetUInt64(symbol, type, parentType),
                SpecialType.System_Double => SetDouble(symbol, type, parentType),
                SpecialType.System_Decimal => SetDecimal(symbol, type, parentType),
                SpecialType.System_Boolean => SetBoolean(symbol, type, parentType),
                SpecialType.System_DateTime => SetDateTime(symbol, type, parentType),
                SpecialType.System_Single => SetFloat(symbol, type, parentType),
                _ => SetUnknownStruct(symbol, type, parentType)
            };
        }

        private static ISymbol? Transform(GeneratorSyntaxContext generatorSyntaxContext, CancellationToken cancellationToken)
        {
            var classDeclaration = generatorSyntaxContext.Node as ClassDeclarationSyntax;
            var classSymbol = ModelExtensions.GetDeclaredSymbol(generatorSyntaxContext.SemanticModel, classDeclaration!, cancellationToken: cancellationToken);
            return classSymbol;
        }

        private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            if (!(syntaxNode is ClassDeclarationSyntax classDeclaration))
                return false;

            if (!classDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword) && !classDeclaration.Modifiers.Any(SyntaxKind.InternalKeyword))
                return false;

            if (!classDeclaration.Modifiers.Any(SyntaxKind.PartialKeyword))
                return false;

            var baseList = classDeclaration.BaseList;
            if (baseList == null)
                return false;

            var types = baseList.Types;
            if (types.Count == 0)
                return false;

            foreach (var type in types)
            {
                if (!(type.Type is IdentifierNameSyntax identifier))
                    continue;

                if (!identifier.Identifier.Text.Equals(nameof(IRedisHashMap), StringComparison.Ordinal))
                    continue;

                return true;
            }

            return false;
        }

        private static ISymbol[] GetPropertySymbols(ISymbol typeSymbol)
        {
            Memory<ISymbol> props = new ISymbol[1024];
            var lastIndex = -1;

            if (typeSymbol.Kind != SymbolKind.NamedType)
                return Array.Empty<ISymbol>();

            var ts = (INamedTypeSymbol)typeSymbol;
            foreach (var symbol in ts.GetMembers())
            {
                if (symbol is IPropertySymbol propSymbol)
                {
                    if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
                        continue;

                    props.Span[++lastIndex] = propSymbol;
                }
                else if (symbol is IFieldSymbol fieldSymbol)
                {
                    if (fieldSymbol.AssociatedSymbol != null)
                        continue;
                    if (fieldSymbol.IsReadOnly)
                        continue;

                    props.Span[++lastIndex] = fieldSymbol;
                }
                else
                {
                    continue;
                }
            }

            var baseType = ts.BaseType;
            while (baseType != null)
            {
                foreach (var propSymbol in baseType.GetMembers().OfType<IPropertySymbol>())
                {
                    if (propSymbol.DeclaredAccessibility != Accessibility.Public)
                        continue;
                    if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
                        continue;

                    var exists = false;
                    for (var i = 0; i < lastIndex + 1; i++)
                    {
                        exists = props.Span[i].Name.Equals(propSymbol.Name, StringComparison.Ordinal);
                        if (exists)
                            break;
                    }

                    if (!exists)
                        props.Span[++lastIndex] = propSymbol;
                }

                baseType = baseType.BaseType;
            }

            if (lastIndex == -1)
                return Array.Empty<ISymbol>();

            props = props[..(lastIndex + 1)];
            return props.ToArray();
        }
    }
}