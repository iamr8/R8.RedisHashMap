using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

namespace R8.RedisHashMap
{
    [Generator]
    public class SourceGenerator : IIncrementalGenerator
    {
        // private static readonly List<string> GeneratedTypes = new List<string>();
        private static readonly string SourceGeneratorNamespace = typeof(SourceGenerator).Namespace!;
        private static readonly string SourceGeneratorVersion = typeof(SourceGenerator).Assembly.GetName().Version!.ToString();

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // register a syntax receiver that will create source for any class that implements IRedisCacheModel
            var declares = context.SyntaxProvider
                .CreateSyntaxProvider(Predicate, Transform);

            var provider = context.CompilationProvider.Combine(declares.Collect());

            context.RegisterSourceOutput(provider, Execute);
        }

        private void Execute(SourceProductionContext ctx, (Compilation Left, ImmutableArray<TypeSymbolOptions?> Right) tuple)
        {
            var contexts = new HashSet<string>();
            var allConverters = new List<ConverterTypeSymbol>();
            foreach (var typeOptions in tuple.Right)
            {
                if (typeOptions == null)
                    continue;

                var typeSymbol = typeOptions.TypeSymbol;
                var props = GetPropertySymbols(typeSymbol);
                if (props.Length == 0)
                    continue;

                var objectType = TypeSymbol.Create(typeSymbol);
                if (objectType.Converter != null && !allConverters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, objectType.Converter!.ConverterType)))
                    allConverters.Add(objectType.Converter);

                if (props.Length > 0)
                {
                    foreach (var prop in props)
                    {
                        if (prop.TryGetConverter(out var pc) && !allConverters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, pc!.ConverterType)))
                            allConverters.Add(pc);
                    }
                }

                typeOptions.FullQualifiedName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                typeOptions.ObjectTypeSymbol = objectType;
                typeOptions.Properties = props.ToImmutableArray();
                typeOptions.AssemblyName = typeSymbol.ContainingAssembly.Name;
                GenerateExtensionSource(ctx, typeOptions);

                contexts.Add(typeOptions.AssemblyName);
            }

            if (contexts.Count > 0)
            {
                foreach (var context in contexts)
                {
                    GenerateContextSource(ctx, context);
                }
            }

            if (allConverters.Count > 0)
            {
                foreach (var converter in allConverters)
                {
                    GenerateConverterSource(ctx, converter);
                }
            }

            // var assembly = this.GetType().Assembly.GetName();
            // [CodeDom.Compiler.GeneratedCodeAttribute(""{assembly.Name}"", ""{assembly.Version}"")] 
        }

        private void GenerateContextSource(SourceProductionContext ctx, string context)
        {
            var sourceText = SourceText.From($@"// <auto-generated/>

#nullable enable annotations
#nullable disable warnings

namespace {context}
{{
    internal class RedisHashMapContext
    {{
        private static readonly RedisHashMapContext _default = new RedisHashMapContext();

        public static RedisHashMapContext Default => _default;

        private RedisHashMapContext()
        {{
        }}
    }}
}}
", Encoding.UTF8);
            var fileName = $"{context}.g.cs";
            ctx.AddSource(fileName, sourceText);
        }

        private void GenerateConverterSource(SourceProductionContext ctx, ConverterTypeSymbol converterSymbol)
        {
            var sourceText = SourceText.From($@"// <auto-generated/>
#nullable enable

namespace {converterSymbol.ConverterType.ContainingNamespace}
{{
    public class {converterSymbol.ConverterType.Name}Instance
    {{
        internal static readonly {converterSymbol.ConverterType.Name} Default = new {converterSymbol.ConverterType.Name}();
    }}
}}", Encoding.UTF8);

            var fileName = $"{converterSymbol.ConverterType.ContainingNamespace}.{converterSymbol.ConverterType.Name}.g.cs";

            ctx.AddSource(fileName, sourceText);
            return;
            // ctx.ReportDiagnostic(Diagnostic.Create(
            //     new DiagnosticDescriptor(
            //         "R8.RedisHashMap",
            //         "Generated",
            //         $"Generated source for {displayName}.",
            //         "SourceGeneration",
            //         DiagnosticSeverity.Info,
            //         true),
            //     Location.None));
        }

        private static void GenerateExtensionSource(SourceProductionContext ctx, TypeSymbolOptions modelTypeOptions)
        {
            var displayName = modelTypeOptions.ObjectTypeSymbol.GetDisplayName();
            var sourceText = SourceText.From($@"// Original source: {modelTypeOptions.ObjectTypeSymbol.Type}
// <auto-generated/>

#nullable enable annotations
#nullable disable warnings

using System;
using System.Buffers;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Runtime.CompilerServices;

using StackExchange.Redis;

namespace {modelTypeOptions.TypeSymbol.ContainingNamespace}
{{
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute(""{SourceGeneratorNamespace}"", ""{SourceGeneratorVersion}"")]
    internal static class {displayName}Extensions
    {{
        private static readonly RedisHashMapContext context = {modelTypeOptions.AssemblyName}.RedisHashMapContext.Default;

        {GetHashEntries(modelTypeOptions, modelTypeOptions.ObjectTypeSymbol, modelTypeOptions.Properties)}
    }}
}}", Encoding.UTF8);

            var fileName = $"{modelTypeOptions.TypeSymbol.ContainingNamespace}.{displayName}.g.cs";

            ctx.AddSource(fileName, sourceText);
            // ctx.ReportDiagnostic(Diagnostic.Create(
            //     new DiagnosticDescriptor(
            //         "R8.RedisHashMap",
            //         "Generated",
            //         $"Generated source for {displayName}.",
            //         "SourceGeneration",
            //         DiagnosticSeverity.Info,
            //         true),
            //     Location.None));
        }

        private static string GetHashEntries(TypeSymbolOptions modelTypeOptions, TypeSymbol objectType, ImmutableArray<TypeSymbol> propertyTypes)
        {
            var contextSymbol = modelTypeOptions.TypeSymbol;
            if (objectType is { IsDictionary: true, Type: INamedTypeSymbol nts })
            {
                var keyArgType = TypeSymbol.Create(nts.TypeArguments[0]);
                var valueArgType = TypeSymbol.Create(nts.TypeArguments[1]);

                // var keySupported = keyArgType.TryGetRedisValue(contextSymbol, null, "kvp.Key", "", out var keyLangCode);
                // var valueSupported = valueArgType.TryGetRedisValue(contextSymbol, null, "kvp.Value", "", out var valueLangCode);
//                 langCode.Append(@$"public static HashEntry[] GetHashEntries(this {objectType} obj)
//         {{
//             var entries = new HashEntry[obj.Count];
//
//             var index = -1;
//             foreach (var kvp in obj)
//             {{
//                 {(keySupported ? $"var key = {keyLangCode};" : $"throw new NotSupportedException($\"Cannot convert `{keyArgType.Type}` to `RedisValue`.\");")}
//                 {(valueSupported ? $"var value = {valueLangCode};" : $"throw new NotSupportedException($\"Cannot convert `{valueArgType.Type}` to `RedisValue`.\");")}
//                 {(keySupported && valueSupported ? "entries[++index] = new HashEntry(key, value);" : "")}
//             }}
//
//             return entries;
//         }}");
                return null;
            }
            else
            {
                var writeContents = WriteContents(propertyTypes, false, out var hasSerializeJson, out var hasSerializeString, out var hasSerializeJsonElement);
                var readContents = ReadContents(propertyTypes);
                return @$"{GetFields(modelTypeOptions, propertyTypes)}
        private static readonly ArrayPool<HashEntry> arrayPool = ArrayPool<HashEntry>.Create({propertyTypes.Length}, 1_000);
        private static readonly Encoding encoding = Encoding.UTF8;
        private static readonly HashEntry[] emptyArray = Array.Empty<HashEntry>();

        public static {objectType} Parse(this HashEntry[] entries, JsonSerializerOptions? serializerOptions = null)
        {{
            if (entries == null || entries.Length == 0)
                return default({objectType});

            var obj = new {objectType}();
            for (int i = 0; i < entries.Length; i++)
            {{
                var entry = entries[i];
                var name = entry.Name;
                if (name.IsNullOrEmpty)
                    continue;

                {readContents}
            }}            

            return obj;
        }}

        public static HashEntry[] GetHashEntries(this {objectType} obj, JsonSerializerOptions? serializerOptions = null)
        {{
            HashEntry[] entries = arrayPool.Rent({propertyTypes.Length});
            Span<HashEntry> entriesSpan = entries.AsSpan();
            int index = -1;

            ArrayBufferWriter<byte> bufferWriter = GetReusableBufferWriter();

            try
            {{
                {writeContents}
                if (index == -1)
                    return emptyArray;

                int finalCount = index + 1;
                HashEntry[] resultArray = new HashEntry[finalCount];
                entriesSpan.Slice(0, finalCount).CopyTo(resultArray);
                return resultArray;
            }}
            finally
            {{
                bufferWriter.Clear();
                arrayPool.Return(entries);
            }}
        }}

        [ThreadStatic]
        private static ArrayBufferWriter<byte> _reusableByteBufferWriter;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ArrayBufferWriter<byte> GetReusableBufferWriter()
        {{
            var writer = _reusableByteBufferWriter;
            if (writer == null)
            {{
                writer = new ArrayBufferWriter<byte>();
                _reusableByteBufferWriter = writer;
            }}
            return writer;
        }}{AddSerializeJson(hasSerializeJson)}{AddSerializeString(hasSerializeString)}{AddSerializeJsonElement(hasSerializeJsonElement)}";
            }
        }

        private static string AddSerializeJsonElement(bool hasSerializeJsonElement)
        {
            if (!hasSerializeJsonElement)
                return string.Empty;

            return @"
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static RedisValue SerializeJsonElement(ArrayBufferWriter<byte> bufferWriter, JsonElement value)
        {
            return (RedisValue)value.GetBytesFromBase64();
        }";
        }

        private static string AddSerializeString(bool hasSerializeString)
        {
            if (!hasSerializeString)
                return string.Empty;

            return @"

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static RedisValue SerializeString(ArrayBufferWriter<byte> bufferWriter, ReadOnlySpan<char> value)
        {
            bufferWriter.Clear();
            int byteCount = encoding.GetByteCount(value);
            Span<byte> bytes = bufferWriter.GetSpan(byteCount);
            int bytesWritten = encoding.GetBytes(value, bytes);
            bufferWriter.Advance(bytesWritten);
            return (RedisValue)bufferWriter.WrittenMemory;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static string DeserializeString(RedisValue value)
        {
            if (value.IsInteger)
                return value.ToString();

            return encoding.GetString(((ReadOnlyMemory<byte>)value).Span);
        }";
        }

        private static string AddSerializeJson(bool hasSerializeJson)
        {
            if (!hasSerializeJson)
                return string.Empty;

            return $@"

        [ThreadStatic]
        private static Utf8JsonWriter _reusableJsonWriter;

        private static readonly JsonWriterOptions ReusableJsonWriterOptions = new JsonWriterOptions
        {{
            Indented = false,
            SkipValidation = false
        }};

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static Utf8JsonWriter GetReusableJsonWriter(ArrayBufferWriter<byte> writer)
        {{
            var jsonWriter = _reusableJsonWriter;
            if (jsonWriter == null)
            {{
                jsonWriter = new Utf8JsonWriter(writer, ReusableJsonWriterOptions);
                _reusableJsonWriter = jsonWriter;
            }}
            else
            {{
                jsonWriter.Reset(writer);
            }}
            return jsonWriter;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static RedisValue SerializeJson<TValue>(ArrayBufferWriter<byte> bufferWriter, TValue value, JsonSerializerOptions? serializerOptions)
        {{
            bufferWriter.Clear();
            Utf8JsonWriter jsonWriter = GetReusableJsonWriter(bufferWriter);
            JsonSerializer.Serialize(_reusableJsonWriter, value, serializerOptions);
            _reusableJsonWriter.Flush();
            return (RedisValue)bufferWriter.WrittenMemory;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static TValue DeserializeJson<TValue>(RedisValue value, JsonSerializerOptions? serializerOptions)
        {{
            return JsonSerializer.Deserialize<TValue>(((ReadOnlyMemory<byte>)value).Span, serializerOptions)!;
        }}";
        }

        private static string ReadContents(ImmutableArray<TypeSymbol> propertyTypes)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Length;
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                stringBuilder.Append($"if (name == field_{propertySymbol!.Name})\n                {{\n                    ");
                var wrapper = propertyType.GetGetterContent(propertySymbol);
                if (wrapper != null)
                {
                    stringBuilder.Append($"{wrapper}\n");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");\n");
                }
                stringBuilder.AppendLine("                    continue;\n                }");

                if (index < propertyTypesLength - 1)
                {
                    stringBuilder.Append("\n                ");
                }
            }

            return stringBuilder.ToString();
        }

        private static string WriteContents(ImmutableArray<TypeSymbol> propertyTypes, bool considerJsonTypeInfo, out bool hasSerializeJson, out bool hasSerializeString, out bool hasSerializeJsonElement)
        {
            var stringBuilder = new StringBuilder();
            hasSerializeJson = false;
            hasSerializeString = false;
            hasSerializeJsonElement = false;
            var propertyTypesLength = propertyTypes.Length;
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                var wrapper = propertyType.GetSetter(propertySymbol!, considerJsonTypeInfo, out var _hasSerializeJson, out var _hasSerializeString, out var _hasSerializeJsonElement);
                if (_hasSerializeJson && !hasSerializeJson)
                    hasSerializeJson = true;
                if (_hasSerializeString && !hasSerializeString)
                    hasSerializeString = true;
                if (_hasSerializeJsonElement && !hasSerializeJsonElement)
                    hasSerializeJsonElement = true;

                if (wrapper != null)
                {
                    stringBuilder.Append($"{wrapper}\n");
                    if (index < propertyTypesLength - 1)
                    {
                        stringBuilder.Append("\n                ");
                    }
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");");
                }
            }

            return stringBuilder.ToString();
        }

        private static string GetFields(TypeSymbolOptions modelTypeOptions, ImmutableArray<TypeSymbol> propertyTypes)
        {
            var stringBuilder = new StringBuilder();
            foreach (var propertyType in propertyTypes)
            {
                var redisFieldName = modelTypeOptions.NamingStrategy switch
                {
                    CacheableFieldNamingStrategy.CamelCase => propertyType.Symbol!.Name.ToCamelCase(),
                    CacheableFieldNamingStrategy.SnakeCase => propertyType.Symbol!.Name.ToSnakeCase(),
                    _ => propertyType.Symbol!.Name,
                };
                stringBuilder.Append($"private static readonly RedisValue field_{propertyType.Symbol!.Name} = new RedisValue(\"{redisFieldName}\");\n        ");
            }

            return stringBuilder.ToString();
        }

        // private static string GetParser(ITypeSymbol objectTypeSymbol, TypeSymbol prop)
        // {
        //     if (prop.IsValueType)
        //     {
        //         if (prop.IsUnmanagedType)
        //         {
        //             if (prop.IsEnum)
        //             {
        //                 if (prop.HasConverter)
        //                 {
        //                     if (prop.IsPropertyOrField)
        //                     {
        //                         return $"static (obj, value) => (({objectTypeSymbol})obj).{prop.Symbol!.Name} = {prop.ConverterTypeSymbol}.Default.ConvertFromRedisValue(value)";
        //                     }
        //                     else
        //                     {
        //                         return $"static (_, value) => _ = {prop.ConverterTypeSymbol}.Default.ConvertFromRedisValue(value)";
        //                     }
        //                 }
        //                 else
        //                 {
        //                     if (prop.IsNullable)
        //                         return $"static (obj, value) => !value.IsNullOrEmpty ? ({prop.Type})value.Value : ({prop.Type}?)null";
        //
        //                     return $"static (obj, value) => !value.IsNullOrEmpty ? ({prop.Type})value.Value : default({prop.Type})";
        //                 }
        //             }
        //             else if (prop.HasConverter)
        //             {
        //                 return $"static (obj, value) => {prop.ConverterTypeSymbol}.Default.ConvertFromRedisValue(value)";
        //             }
        //             else
        //             {
        //                 return $"static (obj, value) => ({prop.Type})value";
        //             }
        //         }
        //         else
        //         {
        //             return $"static (obj, value) => throw new NotSupportedException($\"000 Cannot convert {{value}} to {{typeof({prop})}}. Targeted property: {{nameof({prop.Type.Name})}}\");";
        //         }
        //     }
        //     else if (prop.IsReferenceType)
        //     {
        //         if (prop.HasConverter)
        //         {
        //             return $"static (obj, value) => {prop.ConverterTypeSymbol}.Default.ConvertFromRedisValue(value)";
        //         }
        //
        //         if (prop.IsString)
        //         {
        //             return $"static (obj, value) => ({prop})value!";
        //         }
        //         else if (prop.IsJsonDocument)
        //         {
        //             return $"static (obj, value) => Text.Json.JsonDocument.Parse((ReadOnlyMemory<byte>)value)";
        //         }
        //         else
        //         {
        //             // if (objectTypeSymbol.HasJsonSerializable)
        //             // {
        //             //     var underlyingType = TryGetNullableUnderlyingType(propTypeSymbol, out var underlying) ? underlying : propTypeSymbol;
        //             //     return $"value => Text.Json.JsonSerializer.Deserialize<{underlyingType}>(((ReadOnlyMemory<byte>)value).Span, this.Options)!";
        //             // }
        //             // else
        //             // {
        //             //     var underlyingType = TryGetNullableUnderlyingType(propTypeSymbol, out var underlying) ? underlying : propTypeSymbol;
        //             //     return $"value => Text.Json.JsonSerializer.Deserialize<{underlyingType}>(((ReadOnlyMemory<byte>)value).Span, this.Options)!";
        //             // }
        //
        //             return $"(obj, value) => Text.Json.JsonSerializer.Deserialize<{prop.Type}>(((ReadOnlyMemory<byte>)value).Span, this.Options)!";
        //         }
        //     }
        //
        //     return $"static (obj, value) => throw new NotSupportedException($\"CCC Cannot convert {{value}} to {{typeof({prop})}}. Targeted property: {{nameof({prop.Type.Name})}}\");";
        // }

        private static TypeSymbolOptions? Transform(GeneratorSyntaxContext syntaxContext, CancellationToken cancellationToken)
        {
            if (syntaxContext.Node is ClassDeclarationSyntax classDeclaration)
            {
                if (ModelExtensions.GetDeclaredSymbol(syntaxContext.SemanticModel, classDeclaration, cancellationToken: cancellationToken) is INamedTypeSymbol classSymbol)
                {
                    foreach (var attrsListSyntax in classDeclaration.AttributeLists)
                    {
                        foreach (var attrSyntax in attrsListSyntax.Attributes)
                        {
                            if ((syntaxContext.SemanticModel.GetOperation(attrSyntax) as IAttributeOperation)?.Operation is { Type: { Name: nameof(CacheableObjectAttribute) } attrType })
                            {
                                var typeOptions = new TypeSymbolOptions
                                {
                                    TypeSymbol = classSymbol,
                                    NamingStrategy = CacheableFieldNamingStrategy.PascalCase
                                };
                                if (attrSyntax.ArgumentList != null)
                                {
                                    foreach (var argSyntax in attrSyntax.ArgumentList.Arguments)
                                    {
                                        if (argSyntax.Expression is MemberAccessExpressionSyntax { Expression: IdentifierNameSyntax { Identifier: { Text: nameof(CacheableFieldNamingStrategy) } identifier } } memberSyntax)
                                        {
                                            typeOptions.NamingStrategy = memberSyntax.Name.Identifier.Text switch
                                            {
                                                nameof(CacheableFieldNamingStrategy.PascalCase) => CacheableFieldNamingStrategy.PascalCase,
                                                nameof(CacheableFieldNamingStrategy.CamelCase) => CacheableFieldNamingStrategy.CamelCase,
                                                nameof(CacheableFieldNamingStrategy.SnakeCase) => CacheableFieldNamingStrategy.SnakeCase,
                                                _ => typeOptions.NamingStrategy
                                            };
                                        }
                                    }
                                }

                                return typeOptions;
                            }
                        }
                    }
                }
            }

            return null;
        }

        private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            if (syntaxNode is ClassDeclarationSyntax classDeclaration)
            {
                if (!classDeclaration.Modifiers.Any(SyntaxKind.PublicKeyword) && !classDeclaration.Modifiers.Any(SyntaxKind.InternalKeyword))
                    return false;

                foreach (var attrsListSyntax in classDeclaration.AttributeLists)
                {
                    foreach (var attrSyntax in attrsListSyntax.Attributes)
                    {
                        if (attrSyntax.Name is IdentifierNameSyntax)
                        {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        private static TypeSymbol[] GetPropertySymbols(ITypeSymbol objectTypeSymbol)
        {
            if (objectTypeSymbol.Kind != SymbolKind.NamedType)
                return Array.Empty<TypeSymbol>();

            var props = new List<TypeSymbol>();
            var namedTypeSymbol = (INamedTypeSymbol)objectTypeSymbol;
            foreach (var symbol in namedTypeSymbol.GetMembers())
            {
                if (symbol is IPropertySymbol propSymbol)
                {
                    if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
                        continue;

                    if (propSymbol.DeclaredAccessibility == Accessibility.Private)
                    {
                        // if (!includePrivate)
                        continue;
                    }

                    var attributes = propSymbol.GetAttributes();
                    if (attributes.Any(x => x.AttributeClass.Name.Equals(nameof(JsonIgnoreAttribute), StringComparison.Ordinal)))
                        continue;

                    props.Add(TypeSymbol.Create(symbol));
                }
                else if (symbol is IFieldSymbol fieldSymbol)
                {
                    // if (!includeFields)
                    continue;

                    if (fieldSymbol.DeclaredAccessibility == Accessibility.Private)
                    {
                        // if (!includePrivate)
                        continue;
                    }

                    if (fieldSymbol.AssociatedSymbol != null)
                        continue;

                    if (fieldSymbol.IsReadOnly)
                        continue;

                    props.Add(TypeSymbol.Create(symbol));
                }
                else
                {
                    continue;
                }
            }

            // var baseType = namedTypeSymbol.BaseType;
            // while (baseType != null)
            // {
            //     foreach (var propSymbol in baseType.GetMembers().OfType<IPropertySymbol>())
            //     {
            //         if (propSymbol.DeclaredAccessibility != Accessibility.Public)
            //             continue;
            //         if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
            //             continue;
            //
            //         var exists = false;
            //         for (var i = 0; i < lastIndex + 1; i++)
            //         {
            //             exists = props.Span[i].Name.Equals(propSymbol.Name, StringComparison.Ordinal);
            //             if (exists)
            //                 break;
            //         }
            //
            //         if (!exists)
            //             props.Span[++lastIndex] = propSymbol;
            //     }
            //
            //     baseType = baseType.BaseType;
            // }

            // if (lastIndex == -1)
            // return Array.Empty<TypeSymbol>();

            // props = props[..(lastIndex + 1)];
            return props.ToArray();
        }
    }
}