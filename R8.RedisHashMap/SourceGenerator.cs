using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Text;

namespace R8.RedisHashMap
{
    [Generator]
    public class SourceGenerator : IIncrementalGenerator
    {
        // private static readonly List<string> GeneratedTypes = new List<string>();
        private static readonly string SourceGeneratorNamespace = typeof(SourceGenerator).Namespace!;
        private static readonly string SourceGeneratorVersion = typeof(SourceGenerator).Assembly.GetName().Version!.ToString();

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // register a syntax receiver that will create source for any class that implements IRedisCacheModel
            var declares = context.SyntaxProvider
                .CreateSyntaxProvider(Predicate, Transform);

            var provider = context.CompilationProvider.Combine(declares.Collect());

            context.RegisterSourceOutput(provider, Execute);
        }

        private void Execute(SourceProductionContext ctx, (Compilation Left, ImmutableArray<TypeSymbolOptions?> Right) tuple)
        {
            foreach (var typeOptions in Enumerable.OfType<TypeSymbolOptions>(tuple.Right))
            {
                GenerateHelperSource(ctx, typeOptions);
                GeneratePropertyNamesSource(ctx, typeOptions);
            }
        }

        private static void GenerateHelperSource(SourceProductionContext ctx, TypeSymbolOptions typeOptions)
        {
            var sourceText = SourceText.From($@"// Original source: {typeOptions.ObjectTypeSymbol.Type}
// <auto-generated/>

#nullable enable annotations
#nullable disable warnings

using System.Buffers;
using System.Collections.Concurrent;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Runtime.CompilerServices;

using StackExchange.Redis;

namespace {typeOptions.Namespace}
{{
    {typeOptions.AccessibilityModifier} partial {typeOptions.Keyword.Text} {typeOptions.DisplayName}
    {{
        {WriteMethods(typeOptions)}
    }}
}}", Encoding.UTF8);

            var fileName = $"{typeOptions.Namespace}.{typeOptions.DisplayName}.g.cs";

            ctx.AddSource(fileName, sourceText);
        }

        private static void GeneratePropertyNamesSource(SourceProductionContext ctx, TypeSymbolOptions typeOptions)
        {
            var sourceText = SourceText.From($@"// Original source: {typeOptions.ObjectTypeSymbol.Type}
// <auto-generated/>

#nullable enable annotations
#nullable disable warnings

using StackExchange.Redis;

namespace {typeOptions.Namespace}
{{
    {typeOptions.AccessibilityModifier} partial {typeOptions.Keyword.Text} {typeOptions.DisplayName}
    {{
        {GetFields(typeOptions, typeOptions.Properties)}
    }}
}}", Encoding.UTF8);

            var fileName = $"{typeOptions.Namespace}.{typeOptions.DisplayName}.PropertyNames.cs";

            ctx.AddSource(fileName, sourceText);
        }

        private static string WriteMethods(TypeSymbolOptions typeOptions)
        {
            var isDeserialization = typeOptions.GenerationMode == CacheableGenerationMode.Default || typeOptions.GenerationMode == CacheableGenerationMode.Deserialization;
            var isSerialization = typeOptions.GenerationMode == CacheableGenerationMode.Default || typeOptions.GenerationMode == CacheableGenerationMode.Serialization;
            var writeContentsWithSerializerOptions = WriteContentsWithSerializerOptions(typeOptions.Properties, out var writeConverters1);
            var writeContentsWithSerializerContext = WriteContentsWithSerializerContext(typeOptions.Properties, out var writeConverters2);
            var readContentsWithSerializerOptions = ReadContentsWithSerializerOptions(typeOptions.Properties, out var readConverters1);
            var readContentsWithSerializerContext = ReadContentsWithSerializerContext(typeOptions.Properties, out var readConverters2);
            var converters = writeConverters1
                .Concat(writeConverters2)
                .Concat(readConverters1)
                .Concat(readConverters2)
                .Distinct()
                .ToImmutableArray();

            return @$"private static readonly ArrayPool<HashEntry> arrayPool = ArrayPool<HashEntry>.Create({typeOptions.Properties.Count}, 1_000);
        private static readonly HashEntry[] emptyArray = Array.Empty<HashEntry>();

        {string.Join(@"
        ", converters.Select(c => $"private static readonly {c.ConverterType} converter_{c.ConverterName} = new {c.ConverterType}();"))}

        [ThreadStatic] private static ArrayBufferWriter<byte>? _arrayBufferWriter;
        [ThreadStatic] private static Utf8JsonWriter? _utf8JsonWriter;
        private static readonly ConcurrentDictionary<Type, JsonTypeInfo> _jsonTypeInfoCache = new ConcurrentDictionary<Type, JsonTypeInfo>();

        {(isDeserialization ? GetDeserialization(typeOptions, readContentsWithSerializerOptions, readContentsWithSerializerContext) : "")}{(isSerialization ? GetSerialization(typeOptions, writeContentsWithSerializerOptions, writeContentsWithSerializerContext) : "")}
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ArrayBufferWriter<byte> GetArrayBufferWriter()
        {{
            var writer = _arrayBufferWriter;
            if (writer == null)
            {{
                writer = new ArrayBufferWriter<byte>();
                _arrayBufferWriter = writer;
            }}

            return writer;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static Utf8JsonWriter GetUtf8JsonWriter(ArrayBufferWriter<byte> bufferWriter)
        {{
            var jsonWriter = _utf8JsonWriter;
            if (jsonWriter == null)
            {{
                jsonWriter = new Utf8JsonWriter(bufferWriter, {nameof(RedisJsonSerializer)}.{nameof(RedisJsonSerializer.ReusableJsonWriterOptions)});
                _utf8JsonWriter = jsonWriter;
            }}
            else
            {{
                jsonWriter.Reset(bufferWriter);
            }}

            return jsonWriter;
        }}

        private static JsonTypeInfo<TValue> GetJsonTypeInfo<TValue>(JsonSerializerContext serializerContext)
        {{
            var type = typeof(TValue);
            if (_jsonTypeInfoCache.TryGetValue(type, out var jsonTypeInfo))
                return (JsonTypeInfo<TValue>)jsonTypeInfo;

            jsonTypeInfo = serializerContext.GetTypeInfo(type) as JsonTypeInfo<TValue>;
            if (jsonTypeInfo == null)
                throw new InvalidOperationException($""JsonTypeInfo for type '{{type.FullName}}' not found in the provided serializer context."");

            _jsonTypeInfoCache[type] = jsonTypeInfo;
            return (JsonTypeInfo<TValue>)jsonTypeInfo;
        }}";
        }

        private static string GetSerialization(TypeSymbolOptions typeOptions, string writeContentsWithSerializerOptions, string writeContentsWithSerializerContext)
        {
            return $@"/// <summary>
        /// Generates an array of <see cref=""HashEntry""/> from the current object's properties using the specified <see cref=""JsonSerializerContext""/>.
        /// </summary>
        /// <param name=""serializerContext"">The <see cref=""JsonSerializerContext""/> used to serialize certain fields into JSON format.</param>
        /// <returns>An array of <see cref=""HashEntry""/> containing serialized representations of the object's properties.</returns>
        public HashEntry[] GetHashEntries(JsonSerializerContext serializerContext)
        {{
            HashEntry[] entries = arrayPool.Rent({typeOptions.Properties.Count});
            Span<HashEntry> entriesSpan = entries.AsSpan();
            int index = -1;

            ArrayBufferWriter<byte> bufferWriter = GetArrayBufferWriter();
            Utf8JsonWriter? jsonWriter = null;

            try
            {{
                {writeContentsWithSerializerContext}
                if (index == -1)
                    return emptyArray;

                int finalCount = index + 1;
                HashEntry[] resultArray = new HashEntry[finalCount];
                if (finalCount > 0)
                {{
                    Array.Copy(entries, 0, resultArray, 0, finalCount);
                }}

                return resultArray;
            }}
            finally
            {{
                bufferWriter.Clear();
                arrayPool.Return(entries);
            }}
        }}

        /// <summary>
        /// Converts the current instance of the {typeOptions.DisplayName} class into an array of <see cref=""HashEntry""/> objects.
        /// </summary>
        /// <param name=""serializerOptions"">Optional <see cref=""JsonSerializerOptions""/> used for serializing the properties of the {typeOptions.DisplayName}.</param>
        /// <returns>An array of <see cref=""HashEntry""/> representing the fields and values of the {typeOptions.DisplayName} instance.</returns>
        public HashEntry[] GetHashEntries(JsonSerializerOptions? serializerOptions = null)
        {{
            HashEntry[] entries = arrayPool.Rent({typeOptions.Properties.Count});
            Span<HashEntry> entriesSpan = entries.AsSpan();
            int index = -1;

            ArrayBufferWriter<byte> bufferWriter = GetArrayBufferWriter();
            Utf8JsonWriter? jsonWriter = null;

            try
            {{
                {writeContentsWithSerializerOptions}
                if (index == -1)
                    return emptyArray;

                int finalCount = index + 1;
                HashEntry[] resultArray = new HashEntry[finalCount];
                if (finalCount > 0)
                {{
                    Array.Copy(entries, 0, resultArray, 0, finalCount);
                }}

                return resultArray;
            }}
            finally
            {{
                bufferWriter.Clear();
                arrayPool.Return(entries);
            }}
        }}
";
        }

        private static string GetDeserialization(TypeSymbolOptions typeOptions, string readContentsWithSerializerOptions, string readContentsWithSerializerContext)
        {
            return $@"/// <summary>
        /// Initializes a new instance of the {typeOptions.DisplayName} class by mapping the given hash entries to its properties.
        /// </summary>
        /// <param name=""entries"">An array of <see cref=""HashEntry""/> containing the data used to populate the {typeOptions.DisplayName}.</param>
        /// <param name=""serializerOptions"">Optional <see cref=""JsonSerializerOptions""/> used for deserializing certain fields.</param>
        /// <returns>A <see cref=""{typeOptions.DisplayName}""/> instance populated with values from the hash entries.</returns>
        public static {typeOptions.ObjectTypeSymbol}{(typeOptions.ObjectTypeSymbol.IsNullable ? "?" : "")} FromHashEntries(HashEntry[] entries, JsonSerializerOptions? serializerOptions = null)
        {{
            var length = entries.Length;
            if (length == 0)
                return {(typeOptions.ObjectTypeSymbol.IsNullable ? "null" : "default")};

            {typeOptions.ObjectTypeSymbol}{(typeOptions.ObjectTypeSymbol.IsNullable ? "?" : "")} obj = {(typeOptions.ObjectTypeSymbol.IsNullable ? "null" : "default")};
            for (int i = 0; i < length; i++)
            {{
                HashEntry entry = entries[i];
                RedisValue name = entry.Name;
                if (name.IsNullOrEmpty)
                    continue; // The field is not found in the hash

                obj ??= new {typeOptions.ObjectTypeSymbol}();
                switch (name)
                {{
{readContentsWithSerializerOptions}
                }}
            }}            

            return obj;
        }}

        /// <summary>
        /// Creates a new instance of the <see cref=""{typeOptions.DisplayName}""/> class by mapping the given hash entries
        /// to its properties using the specified serializer context.
        /// </summary>
        /// <param name=""entries"">An array of <see cref=""HashEntry""/> containing the data to populate the <see cref=""{typeOptions.DisplayName}""/> instance.</param>
        /// <param name=""serializerContext"">The <see cref=""JsonSerializerContext""/> used for deserialization of certain fields requiring type information.</param>
        /// <returns>An instance of <see cref=""{typeOptions.DisplayName}""/> populated with values from the specified hash entries.</returns>
        public static {typeOptions.ObjectTypeSymbol}{(typeOptions.ObjectTypeSymbol.IsNullable ? "?" : "")} FromHashEntries(HashEntry[] entries, JsonSerializerContext serializerContext)
        {{
            var length = entries.Length;
            if (length == 0)
                return {(typeOptions.ObjectTypeSymbol.IsNullable ? "null" : "default")};

            {typeOptions.ObjectTypeSymbol}{(typeOptions.ObjectTypeSymbol.IsNullable ? "?" : "")} obj = {(typeOptions.ObjectTypeSymbol.IsNullable ? "null" : "default")};
            for (int i = 0; i < length; i++)
            {{
                HashEntry entry = entries[i];
                RedisValue name = entry.Name;
                if (name.IsNullOrEmpty)
                    continue; // The field is not found in the hash

                obj ??= new {typeOptions.ObjectTypeSymbol}();
                switch (name)
                {{
{readContentsWithSerializerContext}
                }}
            }}            

            return obj;
        }}
        
        ";
        }

        private static string ReadContentsWithSerializerOptions(IReadOnlyList<TypeSymbol> propertyTypes, out IReadOnlyList<ConverterTypeSymbol> converters)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Count;
            converters = new List<ConverterTypeSymbol>();
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                stringBuilder.Append($"\t\t\t\t\tcase prop_{propertySymbol!.Name}:\n\t\t\t\t\t{{\n");
                var wrapper = propertyType.GetGetterContentWithSerializerOptions(propertySymbol, out var converter);
                if (wrapper != null)
                {
                    if (converter != null && !converters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, converter.ConverterType)))
                        ((List<ConverterTypeSymbol>)converters).Add(converter);

                    stringBuilder.Append($"\t\t\t\t\t\t{wrapper}\n");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");\n");
                }

                stringBuilder.AppendLine("\t\t\t\t\t\tbreak;\n\t\t\t\t\t}");

                // if (index < propertyTypesLength - 1)
                // {
                //     stringBuilder.Append("\n");
                // }
            }

            return stringBuilder.ToString();
        }

        private static string ReadContentsWithSerializerContext(IReadOnlyList<TypeSymbol> propertyTypes, out IReadOnlyList<ConverterTypeSymbol> converters)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Count;
            converters = new List<ConverterTypeSymbol>();
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                stringBuilder.Append($"\t\t\t\t\tcase prop_{propertySymbol!.Name}:\n\t\t\t\t\t{{\n");
                var wrapper = propertyType.GetGetterContentWithSerializerContext(propertySymbol, out var converter);
                if (wrapper != null)
                {
                    if (converter != null && !converters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, converter.ConverterType)))
                        ((List<ConverterTypeSymbol>)converters).Add(converter);

                    stringBuilder.Append($"\t\t\t\t\t\t{wrapper}\n");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");\n");
                }

                stringBuilder.AppendLine("\t\t\t\t\t\tbreak;\n\t\t\t\t\t}");

                // if (index < propertyTypesLength - 1)
                // {
                //     stringBuilder.Append("\n");
                // }
            }

            return stringBuilder.ToString();
        }

        private static string WriteContentsWithSerializerOptions(IReadOnlyList<TypeSymbol> propertyTypes, out IReadOnlyList<ConverterTypeSymbol> converters)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Count;
            converters = new List<ConverterTypeSymbol>();
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                var content = propertyType.GetSetterContentWithSerializerOptions(propertySymbol!, out var converter);
                var wrapper = propertyType.GetSetterWrapper(propertySymbol!, content);
                if (wrapper != null)
                {
                    if (converter != null && !((List<ConverterTypeSymbol>)converters).Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, converter.ConverterType)))
                        ((List<ConverterTypeSymbol>)converters).Add(converter);

                    stringBuilder.Append($"{wrapper}\n");
                    if (index < propertyTypesLength - 1) stringBuilder.Append("\n                ");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");");
                }
            }

            return stringBuilder.ToString();
        }

        private static string WriteContentsWithSerializerContext(IReadOnlyList<TypeSymbol> propertyTypes, out IReadOnlyList<ConverterTypeSymbol> converters)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Count;
            converters = new List<ConverterTypeSymbol>();
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                var content = propertyType.GetSetterContentWithSerializerContext(propertySymbol!, out var converter);
                var wrapper = propertyType.GetSetterWrapper(propertySymbol!, content);

                if (wrapper != null)
                {
                    if (converter != null && !((List<ConverterTypeSymbol>)converters).Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, converter.ConverterType)))
                        ((List<ConverterTypeSymbol>)converters).Add(converter);

                    stringBuilder.Append($"{wrapper}\n");
                    if (index < propertyTypesLength - 1) stringBuilder.Append("\n                ");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");");
                }
            }

            return stringBuilder.ToString();
        }

        private static string GetFields(TypeSymbolOptions modelTypeOptions, IReadOnlyList<TypeSymbol> propertyTypes)
        {
            var stringBuilder = new StringBuilder();
            for (var index = 0; index < propertyTypes.Count; index++)
            {
                var propertyType = propertyTypes[index];
                var namingStrategy = modelTypeOptions.NamingStrategy switch
                {
                    CacheableFieldNamingStrategy.CamelCase => propertyType.Symbol!.Name.ToCamelCase(),
                    CacheableFieldNamingStrategy.SnakeCase => propertyType.Symbol!.Name.ToSnakeCase(),
                    CacheableFieldNamingStrategy.PascalCase => propertyType.Symbol!.Name,
                    _ => throw new NotSupportedException($"Unsupported naming strategy: {modelTypeOptions.NamingStrategy}")
                };
                stringBuilder.Append($"private const string prop_{propertyType.Symbol!.Name} = \"{namingStrategy}\";\n\t\t");
                stringBuilder.Append($"private static readonly RedisValue field_{propertyType.Symbol!.Name} = new RedisValue(prop_{propertyType.Symbol!.Name});");

                if (index < propertyTypes.Count - 1) stringBuilder.Append("\n\n\t\t");
            }

            return stringBuilder.ToString();
        }

        private static TypeSymbolOptions? Transform(GeneratorSyntaxContext syntaxContext, CancellationToken cancellationToken)
        {
            if (!GetTypeDeclarationSyntax(syntaxContext.Node, out var syntax))
                return null;

            if (!(ModelExtensions.GetDeclaredSymbol(syntaxContext.SemanticModel, syntax, cancellationToken) is INamedTypeSymbol typeSymbol))
                return null;

            var objectTypeSymbol = TypeSymbol.Create(typeSymbol);
            var options = new TypeSymbolOptions
            {
                TypeSymbol = typeSymbol,
                ObjectTypeSymbol = objectTypeSymbol,
                DisplayName = objectTypeSymbol.GetDisplayName(),
                NamingStrategy = CacheableFieldNamingStrategy.PascalCase,
                GenerationMode = CacheableGenerationMode.Default,
                Namespace = typeSymbol.ContainingNamespace.ToString(),
                FullQualifiedName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                AssemblyName = typeSymbol.ContainingAssembly.Name,
                AccessibilityModifier = typeSymbol.DeclaredAccessibility switch
                {
                    Accessibility.Public => "public",
                    Accessibility.Internal => "internal",
                    _ => "public"
                },
                Keyword = syntax.Keyword,
            };

            // has [CacheObject] attribute
            foreach (var attrSyntax in syntax.AttributeLists.SelectMany(attrsListSyntax => attrsListSyntax.Attributes))
            {
                if (!((syntaxContext.SemanticModel.GetOperation(attrSyntax) as IAttributeOperation)?.Operation is { Type: { Name: nameof(CacheObject) } attrType }))
                    continue;

                if (attrSyntax.ArgumentList == null)
                    continue;

                foreach (var argSyntax in attrSyntax.ArgumentList.Arguments)
                {
                    if (!(argSyntax.Expression is MemberAccessExpressionSyntax expressionSyntax))
                        continue;

                    if (!(expressionSyntax.Expression is IdentifierNameSyntax identifierSyntax))
                        continue;

                    var name = identifierSyntax.Identifier.Text;
                    var value = expressionSyntax.Name.Identifier.Text;
                    switch (name)
                    {
                        case nameof(CacheableFieldNamingStrategy):
                        {
                            options.NamingStrategy = value switch
                            {
                                nameof(CacheableFieldNamingStrategy.PascalCase) => CacheableFieldNamingStrategy.PascalCase,
                                nameof(CacheableFieldNamingStrategy.CamelCase) => CacheableFieldNamingStrategy.CamelCase,
                                nameof(CacheableFieldNamingStrategy.SnakeCase) => CacheableFieldNamingStrategy.SnakeCase,
                                _ => options.NamingStrategy
                            };
                            break;
                        }
                        case nameof(CacheableGenerationMode):
                        {
                            options.GenerationMode = value switch
                            {
                                nameof(CacheableGenerationMode.Default) => CacheableGenerationMode.Default,
                                nameof(CacheableGenerationMode.Serialization) => CacheableGenerationMode.Serialization,
                                nameof(CacheableGenerationMode.Deserialization) => CacheableGenerationMode.Deserialization,
                                _ => options.GenerationMode
                            };
                            break;
                        }
                        default:
                            throw new NotSupportedException($"Unsupported member access: {name}");
                    }
                }

                break;
            }

            if (options.ObjectTypeSymbol.Converter != null && !options.Converters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, options.ObjectTypeSymbol.Converter!.ConverterType)))
                options.Converters.Add(options.ObjectTypeSymbol.Converter);

            var members = typeSymbol.GetMembers();
            if (!members.Any(member => member.DeclaredAccessibility == Accessibility.Public || member.DeclaredAccessibility == Accessibility.Internal))
                return null;

            // properties
            foreach (var symbol in members)
            {
                if (symbol.IsStatic)
                    continue;

                if (symbol is IPropertySymbol propertySymbol)
                {
                    var attributes = propertySymbol.GetAttributes();
                    if (attributes.Any(x => x.AttributeClass.Name.Equals(nameof(JsonIgnoreAttribute), StringComparison.Ordinal)))
                        continue; // [JsonIgnore]

                    if (propertySymbol.IsWriteOnly || propertySymbol.IsReadOnly)
                        continue; // No getter method && no setter method

                    if (propertySymbol.SetMethod!.IsInitOnly)
                        continue; // init;

                    if (propertySymbol.IsIndexer)
                        continue; // this[]
                }
                else if (symbol is IFieldSymbol fieldSymbol)
                {
                    if (fieldSymbol.AssociatedSymbol != null)
                        continue; // Backing field

                    if (fieldSymbol.IsReadOnly)
                        continue; // readonly int Foo;
                }
                else
                {
                    continue;
                }

                var item = TypeSymbol.Create(symbol);
                options.Properties.Add(item);

                if (item.TryGetConverter(out var converter) && !options.Converters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, converter!.ConverterType)))
                {
                    options.Converters.Add(converter);
                }
            }

            if (options.Properties.Count == 0)
                return null;

            return options;
        }

        private static bool GetTypeDeclarationSyntax(SyntaxNode syntaxNode, [NotNullWhen(true)] out TypeDeclarationSyntax? syntax)
        {
            if (!(syntaxNode is ClassDeclarationSyntax classDeclaration))
            {
                if (!(syntaxNode is RecordDeclarationSyntax recordDeclaration) || recordDeclaration.ClassOrStructKeyword.IsKind(SyntaxKind.ClassKeyword))
                {
                    syntax = null;
                    return false;
                }

                syntax = recordDeclaration;
            }
            else
            {
                syntax = classDeclaration;
            }

            if (!syntax.Modifiers.Any(SyntaxKind.PublicKeyword) && !syntax.Modifiers.Any(SyntaxKind.InternalKeyword))
                return false;

            if (!syntax.Modifiers.Any(SyntaxKind.PartialKeyword))
                return false;

            return true;
        }

        private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            if (!GetTypeDeclarationSyntax(syntaxNode, out var syntax))
                return false;

            foreach (var attrSyntax in syntax.AttributeLists.SelectMany(attrsListSyntax => attrsListSyntax.Attributes))
            {
                if (attrSyntax.Name is IdentifierNameSyntax)
                {
                    return true;
                }
            }

            return false;
        }

        private static TypeSymbol[] GetPropertySymbols(ITypeSymbol objectTypeSymbol)
        {
            if (objectTypeSymbol.Kind != SymbolKind.NamedType)
                return Array.Empty<TypeSymbol>();

            var props = new List<TypeSymbol>();
            var namedTypeSymbol = (INamedTypeSymbol)objectTypeSymbol;
            foreach (var symbol in namedTypeSymbol.GetMembers())
                if (symbol is IPropertySymbol propSymbol)
                {
                    if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
                        continue;

                    if (propSymbol.DeclaredAccessibility == Accessibility.Private)
                        // if (!includePrivate)
                        continue;

                    var attributes = propSymbol.GetAttributes();
                    if (attributes.Any(x => x.AttributeClass.Name.Equals(nameof(JsonIgnoreAttribute), StringComparison.Ordinal)))
                        continue;

                    props.Add(TypeSymbol.Create(symbol));
                }
                else if (symbol is IFieldSymbol fieldSymbol)
                {
                    // if (!includeFields)
                    continue;

                    if (fieldSymbol.DeclaredAccessibility == Accessibility.Private)
                        // if (!includePrivate)
                        continue;

                    if (fieldSymbol.AssociatedSymbol != null)
                        continue;

                    if (fieldSymbol.IsReadOnly)
                        continue;

                    props.Add(TypeSymbol.Create(symbol));
                }

            // var baseType = namedTypeSymbol.BaseType;
            // while (baseType != null)
            // {
            //     foreach (var propSymbol in baseType.GetMembers().OfType<IPropertySymbol>())
            //     {
            //         if (propSymbol.DeclaredAccessibility != Accessibility.Public)
            //             continue;
            //         if (propSymbol.GetMethod == null || propSymbol.SetMethod == null)
            //             continue;
            //
            //         var exists = false;
            //         for (var i = 0; i < lastIndex + 1; i++)
            //         {
            //             exists = props.Span[i].Name.Equals(propSymbol.Name, StringComparison.Ordinal);
            //             if (exists)
            //                 break;
            //         }
            //
            //         if (!exists)
            //             props.Span[++lastIndex] = propSymbol;
            //     }
            //
            //     baseType = baseType.BaseType;
            // }

            // if (lastIndex == -1)
            // return Array.Empty<TypeSymbol>();

            // props = props[..(lastIndex + 1)];
            return props.ToArray();
        }
    }
}