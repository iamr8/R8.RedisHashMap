using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using System.Text.Json.Serialization;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace R8.RedisHashMap
{
    [Generator]
    public class SourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            // register a syntax receiver that will create source for any class that implements IRedisCacheModel
            var declares = context.SyntaxProvider
                .CreateSyntaxProvider(Predicate, Transform);

            var provider = context.CompilationProvider.Combine(declares.Collect());

            context.RegisterSourceOutput(provider, Execute);
        }

        private static void GenerateContextSource(SourceProductionContext ctx, ContextOptions contextOptions)
        {
            var sourceText = SourceText.From($@"// Original source: {contextOptions.ObjectTypeSymbol.Type}
// <auto-generated/>

#nullable enable annotations
#nullable disable warnings

using System.Buffers;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Runtime.CompilerServices;

using StackExchange.Redis;

namespace {contextOptions.Namespace}
{{
    {contextOptions.AccessibilityModifier} partial {contextOptions.Keyword} {contextOptions.DisplayName}
    {{
        public static readonly {contextOptions.ObjectTypeSymbol} Default = new {contextOptions.ObjectTypeSymbol}();

        {string.Join(@"
        ", contextOptions.Types.Select(typeOptions => $"private readonly Lazy<{typeOptions.ObjectTypeSymbol}RedisHelper> _{typeOptions.DisplayName.ToCamelCase()} = new Lazy<{typeOptions.ObjectTypeSymbol}RedisHelper>(() => new {typeOptions.ObjectTypeSymbol}RedisHelper());"))}

        {string.Join(@"
        ", contextOptions.Types.Select(typeOptions => $"{typeOptions.AccessibilityModifier} {typeOptions.ObjectTypeSymbol}RedisHelper {typeOptions.DisplayName} => _{typeOptions.DisplayName.ToCamelCase()}.Value;"))}
    }}
}}", Encoding.UTF8);

            var fileName = $"{contextOptions.DisplayName}.g.cs";

            ctx.AddSource(fileName, sourceText);
        }

        private static void GenerateConvertersSource(SourceProductionContext ctx, ContextOptions contextOptions)
        {
            var sourceText = SourceText.From($@"// Original source: {contextOptions.ObjectTypeSymbol.Type}
// <auto-generated/>

#nullable enable annotations
#nullable disable warnings

using System.Buffers;
using System.Collections.Concurrent;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Runtime.CompilerServices;

using StackExchange.Redis;

namespace {contextOptions.Namespace}
{{
    {contextOptions.AccessibilityModifier} partial {contextOptions.Keyword} {contextOptions.DisplayName}
    {{
        {string.Join(@"
        ", contextOptions.Converters.Select(c => $"private readonly Lazy<{c.ConverterType}> _{c.ConverterName.ToCamelCase()} = new Lazy<{c.ConverterType}>(() => new {c.ConverterType}());"))}

        {string.Join(@"
        ", contextOptions.Converters.Select(c => $"public {c.ConverterType} {c.ConverterName} => _{c.ConverterName.ToCamelCase()}.Value;"))}
    }}
}}", Encoding.UTF8);

            var fileName = $"{contextOptions.DisplayName}.Converters.g.cs";

            ctx.AddSource(fileName, sourceText);
        }

        private static void GenerateHelperSource(SourceProductionContext ctx, ContextOptions contextOptions, ObjectOptions typeOptions)
        {
            var sourceText = SourceText.From($@"// Original source: {typeOptions.ObjectTypeSymbol.Type}
// <auto-generated/>

#nullable enable annotations
#nullable disable warnings

using System.Buffers;
using System.Collections.Concurrent;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Text.Json.Serialization.Metadata;
using System.Runtime.CompilerServices;

using StackExchange.Redis;

namespace {typeOptions.Namespace}
{{
    {typeOptions.AccessibilityModifier} partial class {typeOptions.DisplayName}RedisHelper
    {{
        {WriteMethods(contextOptions, typeOptions)}
    }}
}}", Encoding.UTF8);

            var fileName = $"{contextOptions.DisplayName}.{typeOptions.DisplayName}.g.cs";

            ctx.AddSource(fileName, sourceText);
        }

        private static void GeneratePropertyNamesSource(SourceProductionContext ctx, ContextOptions contextOptions, ObjectOptions typeOptions)
        {
            var sourceText = SourceText.From($@"// Original source: {typeOptions.ObjectTypeSymbol.Type}
// <auto-generated/>

#nullable enable annotations
#nullable disable warnings

using StackExchange.Redis;

namespace {typeOptions.Namespace}
{{
    {typeOptions.AccessibilityModifier} partial class {typeOptions.DisplayName}RedisHelper
    {{
        {GetFields(contextOptions, typeOptions)}
    }}
}}", Encoding.UTF8);

            var fileName = $"{contextOptions.DisplayName}.{typeOptions.DisplayName}.PropertyNames.g.cs";

            ctx.AddSource(fileName, sourceText);
        }

        private static string WriteMethods(ContextOptions contextOptions, ObjectOptions typeOptions)
        {
            var generationMode = typeOptions.GenerationMode ?? contextOptions.GenerationMode;
            var isDeserialization = generationMode == CacheGenerationMode.Default || generationMode == CacheGenerationMode.Deserialization;
            var isSerialization = generationMode == CacheGenerationMode.Default || generationMode == CacheGenerationMode.Serialization;
            var writeContentsWithSerializerOptions = WriteContentsWithSerializerOptions(contextOptions, typeOptions.Properties);
            var writeContentsWithSerializerContext = WriteContentsWithSerializerContext(contextOptions, typeOptions.Properties);
            var readContentsWithSerializerOptions = ReadContentsWithSerializerOptions(contextOptions, typeOptions.Properties);
            var readContentsWithSerializerContext = ReadContentsWithSerializerContext(contextOptions, typeOptions.Properties);

            return @$"private static readonly ArrayPool<HashEntry> arrayPool = ArrayPool<HashEntry>.Create({typeOptions.Properties.Count}, 1_000);

        {(typeOptions.Properties.Any(c => c.HasUtf8JsonWriter) ? @"
        [ThreadStatic] private static ArrayBufferWriter<byte>? _arrayBufferWriter;
        [ThreadStatic] private static Utf8JsonWriter? _utf8JsonWriter;" : "")}

        {(isDeserialization ? GetDeserialization(typeOptions, readContentsWithSerializerOptions, readContentsWithSerializerContext) : "")}{(isSerialization ? GetSerialization(typeOptions, writeContentsWithSerializerOptions, writeContentsWithSerializerContext) : "")}
{(typeOptions.Properties.Any(c => c.HasUtf8JsonWriter) ? @$"        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static ArrayBufferWriter<byte> GetArrayBufferWriter()
        {{
            var writer = _arrayBufferWriter;
            if (writer == null)
            {{
                writer = new ArrayBufferWriter<byte>();
                _arrayBufferWriter = writer;
            }}

            return writer;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static Utf8JsonWriter GetUtf8JsonWriter(ArrayBufferWriter<byte> bufferWriter)
        {{
            var jsonWriter = _utf8JsonWriter;
            if (jsonWriter == null)
            {{
                jsonWriter = new Utf8JsonWriter(bufferWriter, {nameof(PooledJsonSerializer)}.{nameof(PooledJsonSerializer.ReusableJsonWriterOptions)});
                _utf8JsonWriter = jsonWriter;
            }}
            else
            {{
                jsonWriter.Reset(bufferWriter);
            }}

            return jsonWriter;
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ReadOnlyMemory<byte> GetBytes<T>(ArrayBufferWriter<byte> arrayBufferWriter, Utf8JsonWriter utf8JsonWriter, T value, JsonSerializerOptions? serializerOptions = null)
        {{
            arrayBufferWriter.Clear();
            utf8JsonWriter.Reset(arrayBufferWriter);
            return {nameof(PooledJsonSerializer)}.{nameof(PooledJsonSerializer.GetBytes)}<T>(utf8JsonWriter!, arrayBufferWriter!, value, serializerOptions);
        }}

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ReadOnlyMemory<byte> GetBytes<T>(ArrayBufferWriter<byte>? arrayBufferWriter, Utf8JsonWriter? utf8JsonWriter, T value, JsonSerializerContext serializerContext)
        {{
            arrayBufferWriter.Clear();
            utf8JsonWriter.Reset(arrayBufferWriter);
            return serializerContext.GetTypeInfo(typeof(T)) is JsonTypeInfo<T> jsonType
                ? {nameof(PooledJsonSerializer)}.{nameof(PooledJsonSerializer.GetBytes)}<T>(utf8JsonWriter!, arrayBufferWriter!, value, jsonType)
                : {nameof(PooledJsonSerializer)}.{nameof(PooledJsonSerializer.GetBytes)}<T>(utf8JsonWriter!, arrayBufferWriter!, value, serializerContext.Options);
        }}" : "")}";
        }

        private static string GetSerialization(ObjectOptions typeOptions, string writeContentsWithSerializerOptions, string writeContentsWithSerializerContext)
        {
            return $@"/// <summary>
        /// Generates an array of <see cref=""HashEntry""/> from the current object's properties using the specified <see cref=""JsonSerializerContext""/>.
        /// </summary>
        /// <param name=""obj"">The {typeOptions.ObjectTypeSymbol} instance to serialize.</param>
        /// <param name=""serializerContext"">The <see cref=""JsonSerializerContext""/> used to serialize certain fields into JSON format.</param>
        /// <returns>An array of <see cref=""HashEntry""/> containing serialized representations of the object's properties.</returns>
        public HashEntry[] GetHashEntries({typeOptions.ObjectTypeSymbol} obj, JsonSerializerContext serializerContext)
        {{
            HashEntry[] entries = arrayPool.Rent({typeOptions.Properties.Count});
            Span<HashEntry> entriesSpan = entries.AsSpan();
            int index = -1;
            {(typeOptions.Properties.Any(c=>c.HasUtf8JsonWriter) ? @"
            ArrayBufferWriter<byte>? arrayBufferWriter = null;
            Utf8JsonWriter? utf8JsonWriter = null;" : "")}

            try
            {{
                {writeContentsWithSerializerContext}
                if (index == -1)
                    return Array.Empty<HashEntry>();

                int finalCount = index + 1;
                HashEntry[] resultArray = new HashEntry[finalCount];
                Array.Copy(entries, 0, resultArray, 0, finalCount);

                return resultArray;
            }}
            finally
            {{
                {(typeOptions.Properties.Any(c => c.HasUtf8JsonWriter) ? "arrayBufferWriter?.Clear();" : "")}
                arrayPool.Return(entries);
            }}
        }}

        /// <summary>
        /// Converts the current instance of the {typeOptions.DisplayName} class into an array of <see cref=""HashEntry""/> objects.
        /// </summary>
        /// <param name=""obj"">The {typeOptions.ObjectTypeSymbol} instance to serialize.</param>
        /// <param name=""serializerOptions"">Optional <see cref=""JsonSerializerOptions""/> used for serializing the properties of the {typeOptions.ObjectTypeSymbol}.</param>
        /// <returns>An array of <see cref=""HashEntry""/> representing the fields and values of the {typeOptions.ObjectTypeSymbol} instance.</returns>
        public HashEntry[] GetHashEntries({typeOptions.ObjectTypeSymbol} obj, JsonSerializerOptions? serializerOptions = null)
        {{
            HashEntry[] entries = arrayPool.Rent({typeOptions.Properties.Count});
            Span<HashEntry> entriesSpan = entries.AsSpan();
            int index = -1;
            {(typeOptions.Properties.Any(c=>c.HasUtf8JsonWriter) ? @"
            ArrayBufferWriter<byte>? arrayBufferWriter = null;
            Utf8JsonWriter? utf8JsonWriter = null;" : "")}

            try
            {{
                {writeContentsWithSerializerOptions}
                if (index == -1)
                    return Array.Empty<HashEntry>();

                int finalCount = index + 1;
                HashEntry[] resultArray = new HashEntry[finalCount];
                Array.Copy(entries, 0, resultArray, 0, finalCount);

                return resultArray;
            }}
            finally
            {{
                {(typeOptions.Properties.Any(c => c.HasUtf8JsonWriter) ? "arrayBufferWriter?.Clear();" : "")}
                arrayPool.Return(entries);
            }}
        }}
";
        }

        private static string GetDeserialization(ObjectOptions typeOptions, string readContentsWithSerializerOptions, string readContentsWithSerializerContext)
        {
            return $@"/// <summary>
        /// Initializes a new instance of the {typeOptions.ObjectTypeSymbol} class by mapping the given hash entries to its properties.
        /// </summary>
        /// <param name=""entries"">An array of <see cref=""HashEntry""/> containing the data used to populate the {typeOptions.ObjectTypeSymbol}.</param>
        /// <param name=""serializerOptions"">Optional <see cref=""JsonSerializerOptions""/> used for deserializing certain fields.</param>
        /// <returns>A <see cref=""{typeOptions.ObjectTypeSymbol}""/> instance populated with values from the hash entries.</returns>
        public {typeOptions.ObjectTypeSymbol}{(typeOptions.ObjectTypeSymbol.IsNullable ? "?" : "")} FromHashEntries(HashEntry[] entries, JsonSerializerOptions? serializerOptions = null)
        {{
            var length = entries.Length;
            if (length == 0)
                return {(typeOptions.ObjectTypeSymbol.IsNullable ? "null" : "default")};

            {typeOptions.ObjectTypeSymbol}{(typeOptions.ObjectTypeSymbol.IsNullable ? "?" : "")} obj = {(typeOptions.ObjectTypeSymbol.IsNullable ? "null" : "default")};
            for (int i = 0; i < length; i++)
            {{
                HashEntry entry = entries[i];
                RedisValue name = entry.Name;
                if (name.IsNullOrEmpty)
                    continue; // The field is not found in the hash

                obj ??= new {typeOptions.ObjectTypeSymbol}();
                switch (name)
                {{
{readContentsWithSerializerOptions}
                }}
            }}            

            return obj;
        }}

        /// <summary>
        /// Creates a new instance of the <see cref=""{typeOptions.ObjectTypeSymbol}""/> class by mapping the given hash entries
        /// to its properties using the specified serializer context.
        /// </summary>
        /// <param name=""entries"">An array of <see cref=""HashEntry""/> containing the data to populate the <see cref=""{typeOptions.ObjectTypeSymbol}""/> instance.</param>
        /// <param name=""serializerContext"">The <see cref=""JsonSerializerContext""/> used for deserialization of certain fields requiring type information.</param>
        /// <returns>A <see cref=""{typeOptions.ObjectTypeSymbol}""/> instance populated with values from the hash entries.</returns>
        public {typeOptions.ObjectTypeSymbol}{(typeOptions.ObjectTypeSymbol.IsNullable ? "?" : "")} FromHashEntries(HashEntry[] entries, JsonSerializerContext serializerContext)
        {{
            var length = entries.Length;
            if (length == 0)
                return {(typeOptions.ObjectTypeSymbol.IsNullable ? "null" : "default")};

            {typeOptions.ObjectTypeSymbol}{(typeOptions.ObjectTypeSymbol.IsNullable ? "?" : "")} obj = {(typeOptions.ObjectTypeSymbol.IsNullable ? "null" : "default")};
            for (int i = 0; i < length; i++)
            {{
                HashEntry entry = entries[i];
                RedisValue name = entry.Name;
                if (name.IsNullOrEmpty)
                    continue; // The field is not found in the hash

                obj ??= new {typeOptions.ObjectTypeSymbol}();
                switch (name)
                {{
{readContentsWithSerializerContext}
                }}
            }}            

            return obj;
        }}";
        }

        private static string ReadContentsWithSerializerOptions(ContextOptions contextOptions, IReadOnlyList<TypeSymbol> propertyTypes)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Count;
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                stringBuilder.Append($"\t\t\t\t\tcase prop_{propertySymbol!.Name}:\n\t\t\t\t\t{{\n");
                var wrapper = propertyType.GetGetterContentWithSerializerOptions(contextOptions, propertySymbol);
                if (wrapper != null)
                {
                    stringBuilder.Append($"\t\t\t\t\t\t{wrapper}\n");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");\n");
                }

                stringBuilder.AppendLine("\t\t\t\t\t\tbreak;\n\t\t\t\t\t}");
            }

            return stringBuilder.ToString();
        }

        private static string ReadContentsWithSerializerContext(ContextOptions contextOptions, IReadOnlyList<TypeSymbol> propertyTypes)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Count;
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                stringBuilder.Append($"\t\t\t\t\tcase prop_{propertySymbol!.Name}:\n\t\t\t\t\t{{\n");
                var wrapper = propertyType.GetGetterContentWithSerializerContext(contextOptions, propertySymbol);
                if (wrapper != null)
                {
                    stringBuilder.Append($"\t\t\t\t\t\t{wrapper}\n");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");\n");
                }

                stringBuilder.AppendLine("\t\t\t\t\t\tbreak;\n\t\t\t\t\t}");
            }

            return stringBuilder.ToString();
        }

        private static string WriteContentsWithSerializerOptions(ContextOptions contextOptions, IReadOnlyList<TypeSymbol> propertyTypes)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Count;
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                // var parser = GetParser(objectTypeSymbol, property);
                var propertySymbol = propertyType.Symbol;
                var content = propertyType.GetSetterContentWithSerializerOptions(contextOptions, propertySymbol!);
                var wrapper = propertyType.GetSetterWrapper(propertySymbol!, content);
                if (wrapper != null)
                {
                    stringBuilder.Append($"{wrapper}\n");
                    if (index < propertyTypesLength - 1) stringBuilder.Append("\n                ");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");");
                }
            }

            return stringBuilder.ToString();
        }

        private static string WriteContentsWithSerializerContext(ContextOptions contextOptions, IReadOnlyList<TypeSymbol> propertyTypes)
        {
            var stringBuilder = new StringBuilder();
            var propertyTypesLength = propertyTypes.Count;
            for (var index = 0; index < propertyTypesLength; index++)
            {
                var propertyType = propertyTypes[index];
                var propertySymbol = propertyType.Symbol;
                var content = propertyType.GetSetterContentWithSerializerContext(contextOptions, propertySymbol!);
                var wrapper = propertyType.GetSetterWrapper(propertySymbol!, content);

                if (wrapper != null)
                {
                    stringBuilder.Append($"{wrapper}\n");
                    if (index < propertyTypesLength - 1) stringBuilder.Append("\n                ");
                }
                else
                {
                    stringBuilder.AppendLine($"throw new NotSupportedException($\"Cannot convert `{propertyType.Type}` to `RedisValue` for `{propertySymbol}`.\");");
                }
            }

            return stringBuilder.ToString();
        }

        private static string GetFields(ContextOptions contextOptions, ObjectOptions typeOptions)
        {
            var stringBuilder = new StringBuilder();
            for (var index = 0; index < typeOptions.Properties.Count; index++)
            {
                var propertyType = typeOptions.Properties[index];
                var namingStrategy = contextOptions.NamingStrategy switch
                {
                    CacheFieldNamingStrategy.CamelCase => propertyType.Symbol!.Name.ToCamelCase(),
                    CacheFieldNamingStrategy.SnakeCase => propertyType.Symbol!.Name.ToSnakeCase(),
                    CacheFieldNamingStrategy.PascalCase => propertyType.Symbol!.Name,
                    _ => throw new NotSupportedException($"Unsupported naming strategy: {contextOptions.NamingStrategy}")
                };
                stringBuilder.Append($"private const string prop_{propertyType.Symbol!.Name} = \"{namingStrategy}\";\n\t\t");
                stringBuilder.Append($"private static readonly RedisValue field_{propertyType.Symbol!.Name} = new RedisValue(prop_{propertyType.Symbol!.Name});");

                if (index < typeOptions.Properties.Count - 1) stringBuilder.Append("\n\n\t\t");
            }

            return stringBuilder.ToString();
        }

        private static bool TryGetContextSyntax(SyntaxNode syntaxNode, [NotNullWhen(true)] out TypeDeclarationSyntax? syntax)
        {
            if (!(syntaxNode is ClassDeclarationSyntax classDeclaration))
            {
                if (!(syntaxNode is RecordDeclarationSyntax recordDeclaration) || recordDeclaration.ClassOrStructKeyword.IsKind(SyntaxKind.ClassKeyword))
                {
                    syntax = null;
                    return false;
                }

                syntax = recordDeclaration;
            }
            else
            {
                syntax = classDeclaration;
            }
            //
            // if (!syntax.Modifiers.Any(SyntaxKind.PublicKeyword) && !syntax.Modifiers.Any(SyntaxKind.InternalKeyword))
            //     return false;

            if (syntax.AttributeLists.Count == 0)
                return false;

            return true;
        }

        private static bool Predicate(SyntaxNode syntaxNode, CancellationToken cancellationToken)
        {
            return TryGetContextSyntax(syntaxNode, out _);
        }

        private static (INamedTypeSymbol ContextSymbol, TypeDeclarationSyntax Syntax, AttributeSyntax CacheContextAttrSyntax, List<AttributeSyntax> CacheObjectAttrListSyntax)? Transform(GeneratorSyntaxContext syntaxContext, CancellationToken cancellationToken)
        {
            if (!TryGetContextSyntax(syntaxContext.Node, out var syntax))
                return null;

            var symbol = ModelExtensions.GetDeclaredSymbol(syntaxContext.SemanticModel, syntax, cancellationToken);
            if (!(symbol is INamedTypeSymbol contextTypeSymbol))
                return null;

            var cacheObjectAttrSyntaxList = new List<AttributeSyntax>();
            AttributeSyntax? cacheContextAttrSyntax = null;
            foreach (var attrSyntax in syntax.AttributeLists.SelectMany(attrsListSyntax => attrsListSyntax.Attributes))
            {
                var attrName = attrSyntax.Name.ToString();
                if (attrName == nameof(CacheObjectAttribute).Replace(nameof(Attribute), ""))
                {
                    cacheObjectAttrSyntaxList.Add(attrSyntax);
                }
                else if (attrName == nameof(CacheContextAttribute).Replace(nameof(Attribute), ""))
                {
                    cacheContextAttrSyntax = attrSyntax;
                }
            }

            if (cacheContextAttrSyntax == null || cacheObjectAttrSyntaxList.Count == 0)
                return null;

            return (contextTypeSymbol, syntax, cacheContextAttrSyntax, cacheObjectAttrSyntaxList);
        }

        private static void ConfigureByCacheObjects(SourceProductionContext ctx, SemanticModel semanticModel, List<AttributeSyntax> cacheObjectAttrSyntaxList, ContextOptions options, CancellationToken cancellationToken)
        {
            foreach (var attributeSyntax in cacheObjectAttrSyntaxList)
            {
                if (attributeSyntax.ArgumentList == null)
                    continue;

                ObjectOptions? objectTypeOptions = null;

                foreach (var argSyntax in attributeSyntax.ArgumentList.Arguments)
                {
                    if (argSyntax.Expression is TypeOfExpressionSyntax typeOfExpressionSyntax)
                    {
                        if (objectTypeOptions != null)
                            throw new InvalidOperationException("Only one type can be specified for the CacheObject attribute.");
                        if (!(typeOfExpressionSyntax.Type is IdentifierNameSyntax identifierNameSyntax))
                            continue;

                        if (!(semanticModel.GetTypeInfo(typeOfExpressionSyntax.Type, cancellationToken).Type is INamedTypeSymbol typeSymbol))
                            continue;

                        objectTypeOptions = GetObjectOptions(ctx, typeSymbol);
                    }
                    else if (argSyntax.Expression is MemberAccessExpressionSyntax memberAccessExpressionSyntax)
                    {
                        if (!(memberAccessExpressionSyntax.Expression is IdentifierNameSyntax identifierNameSyntax))
                            continue;

                        var name = identifierNameSyntax.Identifier.Text;
                        var value = memberAccessExpressionSyntax.Name.Identifier.Text;
                        switch (name)
                        {
                            case nameof(CacheObjectAttribute.GenerationMode):
                            {
                                objectTypeOptions!.GenerationMode = value switch
                                {
                                    nameof(CacheGenerationMode.Default) => CacheGenerationMode.Default,
                                    nameof(CacheGenerationMode.Serialization) => CacheGenerationMode.Serialization,
                                    nameof(CacheGenerationMode.Deserialization) => CacheGenerationMode.Deserialization,
                                };
                                break;
                            }
                        }
                    }
                }

                if (objectTypeOptions != null)
                    options.Types.Add(objectTypeOptions);
            }
        }

        private static void ConfigureByCacheContext(AttributeSyntax cacheContextAttrSyntax, ContextOptions options)
        {
            if (cacheContextAttrSyntax.ArgumentList != null)
            {
                foreach (var argSyntax in cacheContextAttrSyntax.ArgumentList.Arguments)
                {
                    if (!(argSyntax.Expression is MemberAccessExpressionSyntax { Expression: IdentifierNameSyntax identifierSyntax } expressionSyntax))
                        continue;

                    var propertyName = argSyntax.NameEquals!.Name.Identifier.Text;
                    // var typeName = identifierSyntax.Identifier.Text;
                    var value = expressionSyntax.Name.Identifier.Text;
                    switch (propertyName)
                    {
                        case nameof(CacheContextAttribute.NamingStrategy):
                        {
                            options.NamingStrategy = value switch
                            {
                                nameof(CacheFieldNamingStrategy.PascalCase) => CacheFieldNamingStrategy.PascalCase,
                                nameof(CacheFieldNamingStrategy.CamelCase) => CacheFieldNamingStrategy.CamelCase,
                                nameof(CacheFieldNamingStrategy.SnakeCase) => CacheFieldNamingStrategy.SnakeCase,
                            };
                            break;
                        }
                        case nameof(CacheContextAttribute.GenerationMode):
                        {
                            options.GenerationMode = value switch
                            {
                                nameof(CacheGenerationMode.Default) => CacheGenerationMode.Default,
                                nameof(CacheGenerationMode.Serialization) => CacheGenerationMode.Serialization,
                                nameof(CacheGenerationMode.Deserialization) => CacheGenerationMode.Deserialization,
                            };
                            break;
                        }
                    }
                }
            }
        }


        private static void Execute(SourceProductionContext ctx, (Compilation Left, ImmutableArray<(INamedTypeSymbol ContextSymbol, TypeDeclarationSyntax Syntax, AttributeSyntax CacheContextAttrSyntax, List<AttributeSyntax> CacheObjectAttrListSyntax)?> Right) tuple)
        {
            foreach (var syntaxTuple in tuple.Right)
            {
                if (syntaxTuple == null)
                    continue;

                var (contextTypeSymbol, syntax, cacheContextAttrSyntax, cacheObjectAttrSyntaxList) = syntaxTuple.Value;
                var semanticModel = tuple.Left.GetSemanticModel(syntax.SyntaxTree);
                var contextOptions = GetContextOptions(ctx, contextTypeSymbol, syntax, cacheContextAttrSyntax, semanticModel, cacheObjectAttrSyntaxList);
                if (contextOptions.Types.Count == 0)
                    continue;

                GenerateContextSource(ctx, contextOptions);

                foreach (var typeOptions in contextOptions.Types)
                {
                    GenerateHelperSource(ctx, contextOptions, typeOptions);
                    GeneratePropertyNamesSource(ctx, contextOptions, typeOptions);
                }

                if (contextOptions.Converters.Count > 0)
                {
                    GenerateConvertersSource(ctx, contextOptions);
                }
            }
        }

        private static ContextOptions GetContextOptions(SourceProductionContext ctx, INamedTypeSymbol contextTypeSymbol, TypeDeclarationSyntax syntax, AttributeSyntax cacheContextAttrSyntax, SemanticModel semanticModel, List<AttributeSyntax> cacheObjectAttrSyntaxList)
        {
            // if context is `abstract` 
            if (contextTypeSymbol.IsAbstract)
            {
                ctx.ReportDiagnostic(Diagnostic.Create(SourceGeneratorDiagnostics.AbstractContext, syntax.GetLocation(), contextTypeSymbol.Name));
            }

            var objectTypeSymbol = TypeSymbol.Create(ctx, contextTypeSymbol);
            var contextOptions = new ContextOptions
            {
                ObjectTypeSymbol = objectTypeSymbol,
                DisplayName = objectTypeSymbol.GetDisplayName(),
                Namespace = contextTypeSymbol.ContainingNamespace.ToString(),
                // FullQualifiedName = typeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                // AssemblyName = typeSymbol.ContainingAssembly.Name,
                AccessibilityModifier = contextTypeSymbol.DeclaredAccessibility switch
                {
                    Accessibility.Public => "public",
                    Accessibility.Internal => "internal",
                    _ => "public"
                },
                Keyword = syntax.Keyword,
            };
            ConfigureByCacheContext(cacheContextAttrSyntax, contextOptions);
            ConfigureByCacheObjects(ctx, semanticModel, cacheObjectAttrSyntaxList, contextOptions, ctx.CancellationToken);
            return contextOptions;
        }

        private static ObjectOptions? GetObjectOptions(SourceProductionContext ctx, INamedTypeSymbol typeSymbol)
        {
            var members = typeSymbol.GetMembers();
            if (!members.Any(member => member.DeclaredAccessibility == Accessibility.Public || member.DeclaredAccessibility == Accessibility.Internal))
                return null;

            var objectTypeSymbol = TypeSymbol.Create(ctx, typeSymbol);
            var options = new ObjectOptions
            {
                ObjectTypeSymbol = objectTypeSymbol,
                DisplayName = objectTypeSymbol.GetDisplayName(),
                Namespace = typeSymbol.ContainingNamespace.ToString(),
                AccessibilityModifier = typeSymbol.DeclaredAccessibility switch
                {
                    Accessibility.Public => "public",
                    Accessibility.Internal => "internal",
                    _ => "public"
                },
            };

            if (options.ObjectTypeSymbol.Converter != null && !options.Converters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, options.ObjectTypeSymbol.Converter!.ConverterType)))
                options.Converters.Add(options.ObjectTypeSymbol.Converter);

            // properties
            foreach (var symbol in members)
            {
                if (symbol.IsStatic)
                    continue;

                if (symbol is IPropertySymbol propertySymbol)
                {
                    var attributes = propertySymbol.GetAttributes();
                    if (attributes.Any(x => x.AttributeClass.Name.Equals(nameof(JsonIgnoreAttribute), StringComparison.Ordinal)))
                        continue; // [JsonIgnore]

                    if (propertySymbol.IsWriteOnly || propertySymbol.IsReadOnly)
                        continue; // No getter method && no setter method

                    if (propertySymbol.SetMethod!.IsInitOnly)
                        continue; // init;

                    if (propertySymbol.IsIndexer)
                        continue; // this[]
                }
                else if (symbol is IFieldSymbol fieldSymbol)
                {
                    if (fieldSymbol.AssociatedSymbol != null)
                        continue; // Backing field

                    if (fieldSymbol.IsReadOnly)
                        continue; // readonly int Foo;
                }
                else
                {
                    continue;
                }

                var item = TypeSymbol.Create(ctx, symbol);
                options.Properties.Add(item);

                if (item.Converter != null && !options.Converters.Any(c => SymbolEqualityComparer.Default.Equals(c.ConverterType, item.Converter!.ConverterType)))
                    options.Converters.Add(item.Converter);
            }

            if (options.Properties.Count == 0)
                return null;

            return options;
        }
    }
}